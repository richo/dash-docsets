<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <!-- RD version: 0.9.4  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <title>Class: Encoding::Converter (Ruby 1.9.2) </title>
  <!-- raw_prefix  = '..'   -->
  <link rel="stylesheet" href="../css/obf.css" >

  <script src="../js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="../js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 
</head>

<body id="top" class="class">
<div id="actionbar" style='display:none' >
<div class='wrapper'>
<ul class='grids g0'>
  <li class='grid-2' ><a href='/' target='_top' >Home</a></li>
  <li class='grid-2' ><a href='/core' target='_top' >Core</a></li>
  <li class='grid-2' ><a href='/stdlib' target='_top' >Std-lib</a></li>
  <li class='grid-2' ><a href='/downloads' target='_top' >Downloads</a></li>
  <li class='grid-7 right' id='rd-action-search'><form id="searchbox_011815814100681837392:wnccv6st5qk" action="/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk" ><input name="q" type="text" size="20" >&#160;&#160;<input type="submit" name="sa" value="Search" ><input type="hidden" name="cof" value="FORID:9" ></form>
</li>
</ul>
</div>
</div> <!-- end action bar -->
          <div class='wrapper'>
  <div id="metadata" style='display:none'>
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="../encoding_c.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="encoding.c">encoding.c</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="../Data.html">Data</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-asciicompat_encoding">::asciicompat_encoding</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-search_convpath">::search_convpath</a></li>
          
          <li><a href="#method-i-convert">#convert</a></li>
          
          <li><a href="#method-i-convpath">#convpath</a></li>
          
          <li><a href="#method-i-destination_encoding">#destination_encoding</a></li>
          
          <li><a href="#method-i-finish">#finish</a></li>
          
          <li><a href="#method-i-insert_output">#insert_output</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-last_error">#last_error</a></li>
          
          <li><a href="#method-i-primitive_convert">#primitive_convert</a></li>
          
          <li><a href="#method-i-primitive_errinfo">#primitive_errinfo</a></li>
          
          <li><a href="#method-i-putback">#putback</a></li>
          
          <li><a href="#method-i-replacement">#replacement</a></li>
          
          <li><a href="#method-i-replacement-3D">#replacement=</a></li>
          
          <li><a href="#method-i-source_encoding">#source_encoding</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="../images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="../Encoding.html">Encoding</a></li>
        
          <li><a href="../Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          <li><a href="../Encoding/Converter.html">Encoding::Converter</a></li>
        
          <li><a href="../Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          <li><a href="../Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          <li><a href="../Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          <li><a href="../Process.html">Process</a></li>
        
          <li><a href="../Process/GID.html">Process::GID</a></li>
        
          <li><a href="../Process/Status.html">Process::Status</a></li>
        
          <li><a href="../Process/Sys.html">Process::Sys</a></li>
        
          <li><a href="../Process/UID.html">Process::UID</a></li>
        
          <li><a href="../Enumerator.html">Enumerator</a></li>
        
          <li><a href="../Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          <li><a href="../Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          <li><a href="../File.html">File</a></li>
        
          <li><a href="../File/Constants.html">File::Constants</a></li>
        
          <li><a href="../File/Stat.html">File::Stat</a></li>
        
          <li><a href="../IO.html">IO</a></li>
        
          <li><a href="../IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          <li><a href="../IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          <li><a href="../RubyVM.html">RubyVM</a></li>
        
          <li><a href="../RubyVM/Env.html">RubyVM::Env</a></li>
        
          <li><a href="../RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          <li><a href="../GC.html">GC</a></li>
        
          <li><a href="../GC/Profiler.html">GC::Profiler</a></li>
        
          <li><a href="../Math.html">Math</a></li>
        
          <li><a href="../Math/DomainError.html">Math::DomainError</a></li>
        
          <li><a href="../NameError.html">NameError</a></li>
        
          <li><a href="../NameError/message.html">NameError::message</a></li>
        
          <li><a href="../ARGF.html">ARGF</a></li>
        
          <li><a href="../ArgumentError.html">ArgumentError</a></li>
        
          <li><a href="../Array.html">Array</a></li>
        
          <li><a href="../BasicObject.html">BasicObject</a></li>
        
          <li><a href="../Bignum.html">Bignum</a></li>
        
          <li><a href="../Binding.html">Binding</a></li>
        
          <li><a href="../Class.html">Class</a></li>
        
          <li><a href="../Comparable.html">Comparable</a></li>
        
          <li><a href="../Complex.html">Complex</a></li>
        
          <li><a href="../Continuation.html">Continuation</a></li>
        
          <li><a href="../Data.html">Data</a></li>
        
          <li><a href="../Dir.html">Dir</a></li>
        
          <li><a href="../EOFError.html">EOFError</a></li>
        
          <li><a href="../EncodingError.html">EncodingError</a></li>
        
          <li><a href="../Enumerable.html">Enumerable</a></li>
        
          <li><a href="../Errno.html">Errno</a></li>
        
          <li><a href="../Exception.html">Exception</a></li>
        
          <li><a href="../FalseClass.html">FalseClass</a></li>
        
          <li><a href="../Fiber.html">Fiber</a></li>
        
          <li><a href="../FiberError.html">FiberError</a></li>
        
          <li><a href="../FileTest.html">FileTest</a></li>
        
          <li><a href="../Fixnum.html">Fixnum</a></li>
        
          <li><a href="../Float.html">Float</a></li>
        
          <li><a href="../FloatDomainError.html">FloatDomainError</a></li>
        
          <li><a href="../Hash.html">Hash</a></li>
        
          <li><a href="../IOError.html">IOError</a></li>
        
          <li><a href="../IndexError.html">IndexError</a></li>
        
          <li><a href="../Integer.html">Integer</a></li>
        
          <li><a href="../Interrupt.html">Interrupt</a></li>
        
          <li><a href="../Kernel.html">Kernel</a></li>
        
          <li><a href="../KeyError.html">KeyError</a></li>
        
          <li><a href="../LoadError.html">LoadError</a></li>
        
          <li><a href="../LocalJumpError.html">LocalJumpError</a></li>
        
          <li><a href="../Marshal.html">Marshal</a></li>
        
          <li><a href="../MatchData.html">MatchData</a></li>
        
          <li><a href="../Method.html">Method</a></li>
        
          <li><a href="../Module.html">Module</a></li>
        
          <li><a href="../Mutex.html">Mutex</a></li>
        
          <li><a href="../NilClass.html">NilClass</a></li>
        
          <li><a href="../NoMemoryError.html">NoMemoryError</a></li>
        
          <li><a href="../NoMethodError.html">NoMethodError</a></li>
        
          <li><a href="../NotImplementedError.html">NotImplementedError</a></li>
        
          <li><a href="../Numeric.html">Numeric</a></li>
        
          <li><a href="../Object.html">Object</a></li>
        
          <li><a href="../ObjectSpace.html">ObjectSpace</a></li>
        
          <li><a href="../Proc.html">Proc</a></li>
        
          <li><a href="../Random.html">Random</a></li>
        
          <li><a href="../Range.html">Range</a></li>
        
          <li><a href="../RangeError.html">RangeError</a></li>
        
          <li><a href="../Rational.html">Rational</a></li>
        
          <li><a href="../Regexp.html">Regexp</a></li>
        
          <li><a href="../RegexpError.html">RegexpError</a></li>
        
          <li><a href="../RuntimeError.html">RuntimeError</a></li>
        
          <li><a href="../ScriptError.html">ScriptError</a></li>
        
          <li><a href="../SecurityError.html">SecurityError</a></li>
        
          <li><a href="../Signal.html">Signal</a></li>
        
          <li><a href="../SignalException.html">SignalException</a></li>
        
          <li><a href="../StandardError.html">StandardError</a></li>
        
          <li><a href="../StopIteration.html">StopIteration</a></li>
        
          <li><a href="../String.html">String</a></li>
        
          <li><a href="../Struct.html">Struct</a></li>
        
          <li><a href="../Symbol.html">Symbol</a></li>
        
          <li><a href="../SyntaxError.html">SyntaxError</a></li>
        
          <li><a href="../SystemCallError.html">SystemCallError</a></li>
        
          <li><a href="../SystemExit.html">SystemExit</a></li>
        
          <li><a href="../SystemStackError.html">SystemStackError</a></li>
        
          <li><a href="../Thread.html">Thread</a></li>
        
          <li><a href="../ThreadError.html">ThreadError</a></li>
        
          <li><a href="../ThreadGroup.html">ThreadGroup</a></li>
        
          <li><a href="../Time.html">Time</a></li>
        
          <li><a href="../TrueClass.html">TrueClass</a></li>
        
          <li><a href="../TypeError.html">TypeError</a></li>
        
          <li><a href="../UnboundMethod.html">UnboundMethod</a></li>
        
          <li><a href="../ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          <li><a href="../fatal.html">fatal</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation" style='margin: 10px 10px 10px 10px'>
    <h1 class="class">Encoding::Converter</h1>

    <div id="description" class="description">
      
    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="AFTER_OUTPUT">AFTER_OUTPUT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="CRLF_NEWLINE_DECORATOR">CRLF_NEWLINE_DECORATOR</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="CR_NEWLINE_DECORATOR">CR_NEWLINE_DECORATOR</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="INVALID_MASK">INVALID_MASK</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="INVALID_REPLACE">INVALID_REPLACE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="PARTIAL_INPUT">PARTIAL_INPUT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="UNDEF_HEX_CHARREF">UNDEF_HEX_CHARREF</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="UNDEF_MASK">UNDEF_MASK</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="UNDEF_REPLACE">UNDEF_REPLACE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="UNIVERSAL_NEWLINE_DECORATOR">UNIVERSAL_NEWLINE_DECORATOR</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="XML_ATTR_CONTENT_DECORATOR">XML_ATTR_CONTENT_DECORATOR</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="XML_ATTR_QUOTE_DECORATOR">XML_ATTR_QUOTE_DECORATOR</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="XML_TEXT_DECORATOR">XML_TEXT_DECORATOR</a></dt>
          
          <dd class="description"></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="asciicompat_encoding-method" class="method-detail ">
          <a name="method-c-asciicompat_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.asciicompat_encoding(string) &rarr; encoding or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.asciicompat_encoding(encoding) &rarr; encoding or nil</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the corresponding ASCII compatible encoding.</p>

<p>Returns nil if the argument is an ASCII compatible encoding.</p>

<p>"corresponding ASCII compatible encoding" is a ASCII compatible encoding
which can represents exactly the same characters as the given ASCII
incompatible encoding. So, no conversion undefined error occurs when
converting between the two encodings.</p>

<pre>Encoding::Converter.asciicompat_encoding(&quot;ISO-2022-JP&quot;) #=&gt; #&lt;Encoding:stateless-ISO-2022-JP&gt;
Encoding::Converter.asciicompat_encoding(&quot;UTF-16BE&quot;) #=&gt; #&lt;Encoding:UTF-8&gt;
Encoding::Converter.asciicompat_encoding(&quot;UTF-8&quot;) #=&gt; nil</pre>
            

            
            <div class="method-source-code" id="asciicompat_encoding-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_s_asciicompat_encoding(VALUE klass, VALUE arg)
{
    const char *arg_name, *result_name;
    rb_encoding *arg_enc, *result_enc;

    enc_arg(&amp;arg, &amp;arg_name, &amp;arg_enc);

    result_name = rb_econv_asciicompat_encoding(arg_name);

    if (result_name == NULL)
        return Qnil;

    result_enc = make_encoding(result_name);

    return rb_enc_from_encoding(result_enc);
}</code>
</pre> 
            </div><!-- asciicompat_encoding-source -->
            
          </div>

          

          
        </div><!-- asciicompat_encoding-method -->

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.new(source_encoding, destination_encoding)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.new(source_encoding, destination_encoding, opt)</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.new(convpath)</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>possible options elements:</p>

<pre>hash form:
  :invalid =&gt; nil            # raise error on invalid byte sequence (default)
  :invalid =&gt; :replace       # replace invalid byte sequence
  :undef =&gt; nil              # raise error on undefined conversion (default)
  :undef =&gt; :replace         # replace undefined conversion
  :replace =&gt; string         # replacement string (&quot;?&quot; or &quot;\uFFFD&quot; if not specified)
  :universal_newline =&gt; true # decorator for converting CRLF and CR to LF
  :crlf_newline =&gt; true      # decorator for converting CRLF to LF
  :cr_newline =&gt; true        # decorator for converting CR to LF
  :xml =&gt; :text              # escape as XML CharData.
  :xml =&gt; :attr              # escape as XML AttValue
integer form:
  Encoding::Converter::INVALID_REPLACE
  Encoding::Converter::UNDEF_REPLACE
  Encoding::Converter::UNDEF_HEX_CHARREF
  Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR
  Encoding::Converter::CRLF_NEWLINE_DECORATOR
  Encoding::Converter::CR_NEWLINE_DECORATOR
  Encoding::Converter::XML_TEXT_DECORATOR
  Encoding::Converter::XML_ATTR_CONTENT_DECORATOR
  Encoding::Converter::XML_ATTR_QUOTE_DECORATOR</pre>

<p><a href="Converter.html#method-c-new">Encoding::Converter.new</a> creates
an instance of <a href="Converter.html">Encoding::Converter</a>.</p>

<p>Source_encoding and <a
href="Converter.html#method-i-destination_encoding">destination_encoding</a>
should be a string or <a href="../Encoding.html">Encoding</a> object.</p>

<p>opt should be nil, a hash or an integer.</p>

<p>convpath should be an array. convpath may contain</p>
<ul><li>
<p>two-element arrays which contain encodings or encoding names, or</p>
</li><li>
<p>strings representing decorator names.</p>
</li></ul>

<p><a href="Converter.html#method-c-new">Encoding::Converter.new</a>
optionally takes an option. The option should be a hash or an integer. The
option hash can contain :invalid =&gt; nil, etc. The option integer should
be logical-or of constants such as Encoding::Converter::INVALID_REPLACE,
etc.</p>
<dl class="rdoc-list"><dt>:invalid =&gt; nil</dt>
<dd>
<p>Raise error on invalid byte sequence.  This is a default behavior.</p>
</dd><dt>:invalid =&gt; :replace</dt>
<dd>
<p>Replace invalid byte sequence by replacement string.</p>
</dd><dt>:undef =&gt; nil</dt>
<dd>
<p>Raise an error if a character in <a
href="Converter.html#method-i-source_encoding">source_encoding</a> is not
defined in destination_encoding. This is a default behavior.</p>
</dd><dt>:undef =&gt; :replace</dt>
<dd>
<p>Replace undefined character in <a
href="Converter.html#method-i-destination_encoding">destination_encoding</a>
with replacement string.</p>
</dd><dt>:replace =&gt; string</dt>
<dd>
<p>Specify the replacement string. If not specified, “uFFFD” is used for
Unicode encodings and “?” for others.</p>
</dd><dt>:universal_newline =&gt; true</dt>
<dd>
<p>Convert CRLF and CR to LF.</p>
</dd><dt>:crlf_newline =&gt; true</dt>
<dd>
<p>Convert LF to CRLF.</p>
</dd><dt>:cr_newline =&gt; true</dt>
<dd>
<p>Convert LF to CR.</p>
</dd><dt>:xml =&gt; :text</dt>
<dd>
<p>Escape as XML CharData. This form can be used as a HTML 4.0 #PCDATA.</p>
<ul><li>
<p>‘&amp;’ -&gt; ‘&amp;amp;’</p>
</li><li>
<p>‘&lt;’ -&gt; ‘&amp;lt;’</p>
</li><li>
<p>‘&gt;’ -&gt; ‘&amp;gt;’</p>
</li><li>
<p>undefined characters in <a
href="Converter.html#method-i-destination_encoding">destination_encoding</a>
-&gt; hexadecimal CharRef such as &amp;xHH;</p>
</li></ul>
</dd><dt>:xml =&gt; :attr</dt>
<dd>
<p>Escape as XML AttValue. The converted result is quoted as “…”. This form
can be used as a HTML 4.0 attribute value.</p>
<ul><li>
<p>‘&amp;’ -&gt; ‘&amp;amp;’</p>
</li><li>
<p>‘&lt;’ -&gt; ‘&amp;lt;’</p>
</li><li>
<p>‘&gt;’ -&gt; ‘&amp;gt;’</p>
</li><li>
<p>‘“’ -&gt; ‘&amp;quot;’</p>
</li><li>
<p>undefined characters in <a
href="Converter.html#method-i-destination_encoding">destination_encoding</a>
-&gt; hexadecimal CharRef such as &amp;xHH;</p>
</li></ul>
</dd></dl>

<p>Examples:</p>

<pre># UTF-16BE to UTF-8
ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)

# Usually, decorators such as newline conversion are inserted last.
ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;, :universal_newline =&gt; true)
p ec.convpath #=&gt; [[#&lt;Encoding:UTF-16BE&gt;, #&lt;Encoding:UTF-8&gt;],
              #    &quot;universal_newline&quot;]

# But, if the last encoding is ASCII incompatible,
# decorators are inserted before the last conversion.
ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;, :crlf_newline =&gt; true)
p ec.convpath #=&gt; [&quot;crlf_newline&quot;,
              #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]

# Conversion path can be specified directly.
ec = Encoding::Converter.new([&quot;universal_newline&quot;, [&quot;EUC-JP&quot;, &quot;UTF-8&quot;], [&quot;UTF-8&quot;, &quot;UTF-16BE&quot;]])
p ec.convpath #=&gt; [&quot;universal_newline&quot;,
              #    [#&lt;Encoding:EUC-JP&gt;, #&lt;Encoding:UTF-8&gt;],
              #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_init(int argc, VALUE *argv, VALUE self)
{
    VALUE ecopts;
    volatile VALUE snamev, dnamev;
    const char *sname, *dname;
    rb_encoding *senc, *denc;
    rb_econv_t *ec;
    int ecflags;
    VALUE convpath;

    if (rb_check_typeddata(self, &amp;econv_data_type)) {
        rb_raise(rb_eTypeError, &quot;already initialized&quot;);
    }

    if (argc == 1 &amp;&amp; !NIL_P(convpath = rb_check_array_type(argv[0]))) {
        ec = rb_econv_init_by_convpath(self, convpath, &amp;sname, &amp;dname, &amp;senc, &amp;denc);
        ecflags = 0;
        ecopts = Qnil;
    }
    else {
        econv_args(argc, argv, &amp;snamev, &amp;dnamev, &amp;sname, &amp;dname, &amp;senc, &amp;denc, &amp;ecflags, &amp;ecopts);
        ec = rb_econv_open_opts(sname, dname, ecflags, ecopts);
    }

    if (!ec) {
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));
    }

    if (!DECORATOR_P(sname, dname)) {
        if (!senc)
            senc = make_dummy_encoding(sname);
        if (!denc)
            denc = make_dummy_encoding(dname);
    }

    ec-&gt;source_encoding = senc;
    ec-&gt;destination_encoding = denc;

    DATA_PTR(self) = ec;

    return self;
}</code>
</pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
        <div id="search_convpath-method" class="method-detail ">
          <a name="method-c-search_convpath"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.search_convpath(source_encoding, destination_encoding)         &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.search_convpath(source_encoding, destination_encoding, opt)    &rarr; ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a conversion path.</p>

<pre>p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;)
#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;]]

p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, universal_newline: true)
#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
#    &quot;universal_newline&quot;]

p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;UTF-32BE&quot;, universal_newline: true)
#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
#    &quot;universal_newline&quot;,
#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-32BE&gt;]]</pre>
            

            
            <div class="method-source-code" id="search_convpath-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_s_search_convpath(int argc, VALUE *argv, VALUE klass)
{
    volatile VALUE snamev, dnamev;
    const char *sname, *dname;
    rb_encoding *senc, *denc;
    int ecflags;
    VALUE ecopts;
    VALUE convpath;

    econv_args(argc, argv, &amp;snamev, &amp;dnamev, &amp;sname, &amp;dname, &amp;senc, &amp;denc, &amp;ecflags, &amp;ecopts);

    convpath = Qnil;
    transcode_search_path(sname, dname, search_convpath_i, &amp;convpath);

    if (NIL_P(convpath))
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

    if (decorate_convpath(convpath, ecflags) == -1)
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

    return convpath;
}</code>
</pre> 
            </div><!-- search_convpath-source -->
            
          </div>

          

          
        </div><!-- search_convpath-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="convert-method" class="method-detail ">
          <a name="method-i-convert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">convert(source_string) &rarr; destination_string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Convert source_string and return destination_string.</p>

<p>source_string is assumed as a part of source. i.e.  :partial_input=&gt;true
is specified internally. finish method should be used last.</p>

<pre>ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;euc-jp&quot;)
puts ec.convert(&quot;\u3042&quot;).dump     #=&gt; &quot;\xA4\xA2&quot;
puts ec.finish.dump                #=&gt; &quot;&quot;

ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
puts ec.convert(&quot;\xA4&quot;).dump       #=&gt; &quot;&quot;
puts ec.convert(&quot;\xA2&quot;).dump       #=&gt; &quot;\xE3\x81\x82&quot;
puts ec.finish.dump                #=&gt; &quot;&quot;

ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
puts ec.convert(&quot;\xE3&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
puts ec.convert(&quot;\x81&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
puts ec.convert(&quot;\x82&quot;).dump       #=&gt; &quot;\e$B$\&quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
puts ec.finish.dump                #=&gt; &quot;\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;)</pre>

<p>If a conversion error occur, <a
href="UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
or <a
href="InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
is raised. <a
href="Converter.html#method-i-convert">Encoding::Converter#convert</a>
doesn’t supply methods to recover or restart from these exceptions. When
you want to handle these conversion errors, use <a
href="Converter.html#method-i-primitive_convert">Encoding::Converter#primitive_convert</a>.</p>
            

            
            <div class="method-source-code" id="convert-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_convert(VALUE self, VALUE source_string)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    StringValue(source_string);

    dst = rb_str_new(NULL, 0);

    av[0] = rb_str_dup(source_string);
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2NUM(ECONV_PARTIAL_INPUT);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret == sym_finished) {
        rb_raise(rb_eArgError, &quot;converter already finished&quot;);
    }

    if (ret != sym_source_buffer_empty) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}</code>
</pre> 
            </div><!-- convert-source -->
            
          </div>

          

          
        </div><!-- convert-method -->

      
        <div id="convpath-method" class="method-detail ">
          <a name="method-i-convpath"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">convpath        &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the conversion path of ec.</p>

<p>The result is an array of conversions.</p>

<pre>ec = Encoding::Converter.new(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, crlf_newline: true)
p ec.convpath
#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
#    &quot;crlf_newline&quot;]</pre>

<p>Each element of the array is a pair of encodings or a string. A pair means
an encoding conversion. A string means a decorator.</p>

<p>In the above example, [#&lt;Encoding:ISO-8859-1&gt;,
#&lt;Encoding:UTF-8&gt;] means a converter from ISO-8859-1 to UTF-8.
“crlf_newline” means newline converter from LF to CRLF.</p>
            

            
            <div class="method-source-code" id="convpath-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_convpath(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    VALUE result;
    int i;

    result = rb_ary_new();
    for (i = 0; i &lt; ec-&gt;num_trans; i++) {
        const rb_transcoder *tr = ec-&gt;elems[i].tc-&gt;transcoder;
        VALUE v;
        if (DECORATOR_P(tr-&gt;src_encoding, tr-&gt;dst_encoding))
            v = rb_str_new_cstr(tr-&gt;dst_encoding);
        else
            v = rb_assoc_new(make_encobj(tr-&gt;src_encoding), make_encobj(tr-&gt;dst_encoding));
        rb_ary_push(result, v);
    }
    return result;
}</code>
</pre> 
            </div><!-- convpath-source -->
            
          </div>

          

          
        </div><!-- convpath-method -->

      
        <div id="destination_encoding-method" class="method-detail ">
          <a name="method-i-destination_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">destination_encoding &rarr; encoding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the destination encoding as an <a
href="../Encoding.html">Encoding</a> object.</p>
            

            
            <div class="method-source-code" id="destination_encoding-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_destination_encoding(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    if (!ec-&gt;destination_encoding)
        return Qnil;
    return rb_enc_from_encoding(ec-&gt;destination_encoding);
}</code>
</pre> 
            </div><!-- destination_encoding-source -->
            
          </div>

          

          
        </div><!-- destination_encoding-method -->

      
        <div id="finish-method" class="method-detail ">
          <a name="method-i-finish"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">finish &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Finishes the converter. It returns the last part of the converted string.</p>

<pre>ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
p ec.convert(&quot;\u3042&quot;)     #=&gt; &quot;\e$B$\&quot;&quot;
p ec.finish                #=&gt; &quot;\e(B&quot;</pre>
            

            
            <div class="method-source-code" id="finish-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_finish(VALUE self)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    dst = rb_str_new(NULL, 0);

    av[0] = Qnil;
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2NUM(0);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret != sym_finished) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}</code>
</pre> 
            </div><!-- finish-source -->
            
          </div>

          

          
        </div><!-- finish-method -->

      
        <div id="insert_output-method" class="method-detail ">
          <a name="method-i-insert_output"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">insert_output(string) &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Inserts string into the encoding converter. The string will be converted to
the destination encoding and output on later conversions.</p>

<p>If the destination encoding is stateful, string is converted according to
the state and the state is updated.</p>

<p>This method should be used only when a conversion error occurs.</p>

<pre>ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-8859-1&quot;)
src = &quot;HIRAGANA LETTER A is \u{3042}.&quot;
dst = &quot;&quot;
p ec.primitive_convert(src, dst)    #=&gt; :undefined_conversion
puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;HIRAGANA LETTER A is &quot;, &quot;.&quot;]
ec.insert_output(&quot;&lt;err&gt;&quot;)
p ec.primitive_convert(src, dst)    #=&gt; :finished
puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;HIRAGANA LETTER A is &lt;err&gt;.&quot;, &quot;&quot;]

ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
src = &quot;\u{306F 3041 3068 2661 3002}&quot; # U+2661 is not representable in iso-2022-jp
dst = &quot;&quot;
p ec.primitive_convert(src, dst)    #=&gt; :undefined_conversion
puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;\e$B$O$!$H&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;\xE3\x80\x82&quot;]
ec.insert_output &quot;?&quot;                # state change required to output &quot;?&quot;.
p ec.primitive_convert(src, dst)    #=&gt; :finished
puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;\e$B$O$!$H\e(B?\e$B!#\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;&quot;]</pre>
            

            
            <div class="method-source-code" id="insert_output-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_insert_output(VALUE self, VALUE string)
{
    const char *insert_enc;

    int ret;

    rb_econv_t *ec = check_econv(self);

    StringValue(string);
    insert_enc = rb_econv_encoding_to_insert_output(ec);
    string = rb_str_encode(string, rb_enc_from_encoding(rb_enc_find(insert_enc)), 0, Qnil);

    ret = rb_econv_insert_output(ec, (const unsigned char *)RSTRING_PTR(string), RSTRING_LEN(string), insert_enc);
    if (ret == -1) {
        rb_raise(rb_eArgError, &quot;too big string&quot;);
    }

    return Qnil;
}</code>
</pre> 
            </div><!-- insert_output-source -->
            
          </div>

          

          
        </div><!-- insert_output-method -->

      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inspect         &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a printable version of <em>ec</em></p>

<pre>ec = Encoding::Converter.new(&quot;iso-8859-1&quot;, &quot;utf-8&quot;)
puts ec.inspect    #=&gt; #&lt;Encoding::Converter: ISO-8859-1 to UTF-8&gt;</pre>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_inspect(VALUE self)
{
    const char *cname = rb_obj_classname(self);
    rb_econv_t *ec;

    TypedData_Get_Struct(self, rb_econv_t, &amp;econv_data_type, ec);
    if (!ec)
        return rb_sprintf(&quot;#&lt;%s: uninitialized&gt;&quot;, cname);
    else {
        const char *sname = ec-&gt;source_encoding_name;
        const char *dname = ec-&gt;destination_encoding_name;
        VALUE str;
        str = rb_sprintf(&quot;#&lt;%s: &quot;, cname);
        econv_description(sname, dname, ec-&gt;flags, str);
        rb_str_cat2(str, &quot;&gt;&quot;);
        return str;
    }
}</code>
</pre> 
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->

      
        <div id="last_error-method" class="method-detail ">
          <a name="method-i-last_error"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">last_error &rarr; exception or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an exception object for the last conversion. Returns nil if the
last conversion did not produce an error.</p>

<p>"error" means that <a
href="InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
and <a
href="UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
for <a
href="Converter.html#method-i-convert">Encoding::Converter#convert</a> and
:invalid_byte_sequence, :incomplete_input and :undefined_conversion for <a
href="Converter.html#method-i-primitive_convert">Encoding::Converter#primitive_convert</a>.</p>

<pre>ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-8859-1&quot;)
p ec.primitive_convert(src=&quot;\xf1abcd&quot;, dst=&quot;&quot;)       #=&gt; :invalid_byte_sequence
p ec.last_error      #=&gt; #&lt;Encoding::InvalidByteSequenceError: &quot;\xF1&quot; followed by &quot;a&quot; on UTF-8&gt;
p ec.primitive_convert(src, dst, nil, 1)             #=&gt; :destination_buffer_full
p ec.last_error      #=&gt; nil</pre>
            

            
            <div class="method-source-code" id="last_error-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_last_error(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    VALUE exc;

    exc = make_econv_exception(ec);
    if (NIL_P(exc))
        return Qnil;
    return exc;
}</code>
</pre> 
            </div><!-- last_error-source -->
            
          </div>

          

          
        </div><!-- last_error-method -->

      
        <div id="primitive_convert-method" class="method-detail ">
          <a name="method-i-primitive_convert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">primitive_convert(source_buffer, destination_buffer) &rarr; symbol</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">primitive_convert(source_buffer, destination_buffer, destination_byteoffset) &rarr; symbol</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize) &rarr; symbol</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize, opt) &rarr; symbol</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>possible opt elements:</p>

<pre>hash form:
  :partial_input =&gt; true           # source buffer may be part of larger source
  :after_output =&gt; true            # stop conversion after output before input
integer form:
  Encoding::Converter::PARTIAL_INPUT
  Encoding::Converter::AFTER_OUTPUT</pre>

<p>possible results:</p>

<pre>:invalid_byte_sequence
:incomplete_input
:undefined_conversion
:after_output
:destination_buffer_full
:source_buffer_empty
:finished</pre>

<p><a href="Converter.html#method-i-primitive_convert">primitive_convert</a>
converts source_buffer into destination_buffer.</p>

<p>source_buffer should be a string or nil. nil means a empty string.</p>

<p>destination_buffer should be a string.</p>

<p>destination_byteoffset should be an integer or nil. nil means the end of
destination_buffer. If it is omitted, nil is assumed.</p>

<p>destination_bytesize should be an integer or nil. nil means unlimited. If
it is omitted, nil is assumed.</p>

<p>opt should be nil, a hash or an integer. nil means no flags. If it is
omitted, nil is assumed.</p>

<p><a href="Converter.html#method-i-primitive_convert">primitive_convert</a>
converts the content of source_buffer from beginning and store the result
into destination_buffer.</p>

<p>destination_byteoffset and destination_bytesize specify the region which
the converted result is stored. destination_byteoffset specifies the start
position in destination_buffer in bytes. If destination_byteoffset is nil,
destination_buffer.bytesize is used for appending the result.
destination_bytesize specifies maximum number of bytes. If
destination_bytesize is nil, destination size is unlimited. After
conversion, destination_buffer is resized to destination_byteoffset +
actually produced number of bytes. Also destination_buffer’s encoding is
set to destination_encoding.</p>

<p><a href="Converter.html#method-i-primitive_convert">primitive_convert</a>
drops the converted part of source_buffer. the dropped part is converted in
destination_buffer or buffered in <a
href="Converter.html">Encoding::Converter</a> object.</p>

<p><a href="Converter.html#method-i-primitive_convert">primitive_convert</a>
stops conversion when one of following condition met.</p>
<ul><li>
<p>invalid byte sequence found in source buffer (:invalid_byte_sequence)</p>
</li><li>
<p>unexpected end of source buffer (:incomplete_input) this occur only when
:partial_input is not specified.</p>
</li><li>
<p>character not representable in output encoding (:undefined_conversion)</p>
</li><li>
<p>after some output is generated, before input is done (:after_output) this
occur only when :after_output is specified.</p>
</li><li>
<p>destination buffer is full (:destination_buffer_full) this occur only when
destination_bytesize is non-nil.</p>
</li><li>
<p>source buffer is empty (:source_buffer_empty) this occur only when
:partial_input is specified.</p>
</li><li>
<p>conversion is finished (:finished)</p>
</li></ul>

<p>example:</p>

<pre>ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, nil, 100)
p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;\x00p\x00i&quot;]

ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, nil, 1)
p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;i&quot;, &quot;\x00&quot;]
ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;p&quot;]
ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;\x00&quot;]
ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;i&quot;]</pre>
            

            
            <div class="method-source-code" id="primitive_convert-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_primitive_convert(int argc, VALUE *argv, VALUE self)
{
    VALUE input, output, output_byteoffset_v, output_bytesize_v, opt, flags_v;
    rb_econv_t *ec = check_econv(self);
    rb_econv_result_t res;
    const unsigned char *ip, *is;
    unsigned char *op, *os;
    long output_byteoffset, output_bytesize;
    unsigned long output_byteend;
    int flags;

    rb_scan_args(argc, argv, &quot;23&quot;, &amp;input, &amp;output, &amp;output_byteoffset_v, &amp;output_bytesize_v, &amp;opt);

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = 0; /* dummy */
    else
        output_byteoffset = NUM2LONG(output_byteoffset_v);

    if (NIL_P(output_bytesize_v))
        output_bytesize = 0; /* dummy */
    else
        output_bytesize = NUM2LONG(output_bytesize_v);

    if (NIL_P(opt)) {
        flags = 0;
    }
    else if (!NIL_P(flags_v = rb_check_to_integer(opt, &quot;to_int&quot;))) {
        flags = NUM2INT(flags_v);
    }
    else {
        VALUE v;
        opt = rb_convert_type(opt, T_HASH, &quot;Hash&quot;, &quot;to_hash&quot;);
        flags = 0;
        v = rb_hash_aref(opt, sym_partial_input);
        if (RTEST(v))
            flags |= ECONV_PARTIAL_INPUT;
        v = rb_hash_aref(opt, sym_after_output);
        if (RTEST(v))
            flags |= ECONV_AFTER_OUTPUT;
    }

    StringValue(output);
    if (!NIL_P(input))
        StringValue(input);
    rb_str_modify(output);

    if (NIL_P(output_bytesize_v)) {
        output_bytesize = RSTRING_EMBED_LEN_MAX;
        if (!NIL_P(input) &amp;&amp; output_bytesize &lt; RSTRING_LEN(input))
            output_bytesize = RSTRING_LEN(input);
    }

  retry:

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = RSTRING_LEN(output);

    if (output_byteoffset &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_byteoffset&quot;);

    if (RSTRING_LEN(output) &lt; output_byteoffset)
        rb_raise(rb_eArgError, &quot;output_byteoffset too big&quot;);

    if (output_bytesize &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_bytesize&quot;);

    output_byteend = (unsigned long)output_byteoffset +
                     (unsigned long)output_bytesize;

    if (output_byteend &lt; (unsigned long)output_byteoffset ||
        LONG_MAX &lt; output_byteend)
        rb_raise(rb_eArgError, &quot;output_byteoffset+output_bytesize too big&quot;);

    if (rb_str_capacity(output) &lt; output_byteend)
        rb_str_resize(output, output_byteend);

    if (NIL_P(input)) {
        ip = is = NULL;
    }
    else {
        ip = (const unsigned char *)RSTRING_PTR(input);
        is = ip + RSTRING_LEN(input);
    }

    op = (unsigned char *)RSTRING_PTR(output) + output_byteoffset;
    os = op + output_bytesize;

    res = rb_econv_convert(ec, &amp;ip, is, &amp;op, os, flags);
    rb_str_set_len(output, op-(unsigned char *)RSTRING_PTR(output));
    if (!NIL_P(input))
        rb_str_drop_bytes(input, ip - (unsigned char *)RSTRING_PTR(input));

    if (NIL_P(output_bytesize_v) &amp;&amp; res == econv_destination_buffer_full) {
        if (LONG_MAX / 2 &lt; output_bytesize)
            rb_raise(rb_eArgError, &quot;too long conversion result&quot;);
        output_bytesize *= 2;
        output_byteoffset_v = Qnil;
        goto retry;
    }

    if (ec-&gt;destination_encoding) {
        rb_enc_associate(output, ec-&gt;destination_encoding);
    }

    return econv_result_to_symbol(res);
}</code>
</pre> 
            </div><!-- primitive_convert-source -->
            
          </div>

          

          
        </div><!-- primitive_convert-method -->

      
        <div id="primitive_errinfo-method" class="method-detail ">
          <a name="method-i-primitive_errinfo"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">primitive_errinfo &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p><a href="Converter.html#method-i-primitive_errinfo">primitive_errinfo</a>
returns important information regarding the last error as a 5-element
array:</p>

<pre>[result, enc1, enc2, error_bytes, readagain_bytes]</pre>

<p>result is the last result of primitive_convert.</p>

<p>Other elements are only meaningful when result is :invalid_byte_sequence,
:incomplete_input or :undefined_conversion.</p>

<p>enc1 and enc2 indicate a conversion step as a pair of strings. For example,
a converter from EUC-JP to ISO-8859-1 converts a string as follows: EUC-JP
-&gt; UTF-8 -&gt; ISO-8859-1. So [enc1, enc2] is either [“EUC-JP”, “UTF-8”]
or [“UTF-8”, “ISO-8859-1”].</p>

<p>error_bytes and readagain_bytes indicate the byte sequences which caused
the error. error_bytes is discarded portion. readagain_bytes is buffered
portion which is read again on next conversion.</p>

<p>Example:</p>

<pre># \xff is invalid as EUC-JP.
ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;Shift_JIS&quot;)
ec.primitive_convert(src=&quot;\xff&quot;, dst=&quot;&quot;, nil, 10)
p ec.primitive_errinfo
#=&gt; [:invalid_byte_sequence, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xFF&quot;, &quot;&quot;]

# HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.
# Since this error is occur in UTF-8 to ISO-8859-1 conversion,
# error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).
ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
ec.primitive_convert(src=&quot;\xa4\xa2&quot;, dst=&quot;&quot;, nil, 10)
p ec.primitive_errinfo
#=&gt; [:undefined_conversion, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, &quot;\xE3\x81\x82&quot;, &quot;&quot;]

# partial character is invalid
ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10)
p ec.primitive_errinfo
#=&gt; [:incomplete_input, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xA4&quot;, &quot;&quot;]

# Encoding::Converter::PARTIAL_INPUT prevents invalid errors by
# partial characters.
ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10, Encoding::Converter::PARTIAL_INPUT)
p ec.primitive_errinfo
#=&gt; [:source_buffer_empty, nil, nil, nil, nil]

# \xd8\x00\x00@ is invalid as UTF-16BE because
# no low surrogate after high surrogate (\xd8\x00).
# It is detected by 3rd byte (\00) which is part of next character.
# So the high surrogate (\xd8\x00) is discarded and
# the 3rd byte is read again later.
# Since the byte is buffered in ec, it is dropped from src.
ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)
ec.primitive_convert(src=&quot;\xd8\x00\x00@&quot;, dst=&quot;&quot;, nil, 10)
p ec.primitive_errinfo
#=&gt; [:invalid_byte_sequence, &quot;UTF-16BE&quot;, &quot;UTF-8&quot;, &quot;\xD8\x00&quot;, &quot;\x00&quot;]
p src
#=&gt; &quot;@&quot;

# Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.
# The problem is detected by 4th byte.
ec = Encoding::Converter.new(&quot;UTF-16LE&quot;, &quot;UTF-8&quot;)
ec.primitive_convert(src=&quot;\x00\xd8@\x00&quot;, dst=&quot;&quot;, nil, 10)
p ec.primitive_errinfo
#=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;@\x00&quot;]
p src
#=&gt; &quot;&quot;</pre>
            

            
            <div class="method-source-code" id="primitive_errinfo-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_primitive_errinfo(VALUE self)
{
    rb_econv_t *ec = check_econv(self);

    VALUE ary;

    ary = rb_ary_new2(5);

    rb_ary_store(ary, 0, econv_result_to_symbol(ec-&gt;last_error.result));
    rb_ary_store(ary, 4, Qnil);

    if (ec-&gt;last_error.source_encoding)
        rb_ary_store(ary, 1, rb_str_new2(ec-&gt;last_error.source_encoding));

    if (ec-&gt;last_error.destination_encoding)
        rb_ary_store(ary, 2, rb_str_new2(ec-&gt;last_error.destination_encoding));

    if (ec-&gt;last_error.error_bytes_start) {
        rb_ary_store(ary, 3, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start, ec-&gt;last_error.error_bytes_len));
        rb_ary_store(ary, 4, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start + ec-&gt;last_error.error_bytes_len, ec-&gt;last_error.readagain_len));
    }

    return ary;
}</code>
</pre> 
            </div><!-- primitive_errinfo-source -->
            
          </div>

          

          
        </div><!-- primitive_errinfo-method -->

      
        <div id="putback-method" class="method-detail ">
          <a name="method-i-putback"></a>

          
          <div class="method-heading">
            <span class="method-name">putback</span><span
              class="method-args">(p1 = v1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>call-seq</p>

<pre>ec.putback                    -&gt; string
ec.putback(max_numbytes)      -&gt; string</pre>

<p>Put back the bytes which will be converted.</p>

<p>The bytes are caused by invalid_byte_sequence error. When
invalid_byte_sequence error, some bytes are discarded and some bytes are
buffered to be converted later. The latter bytes can be put back. It can be
observed by <a
href="InvalidByteSequenceError.html#method-i-readagain_bytes">Encoding::InvalidByteSequenceError#readagain_bytes</a>
and <a
href="Converter.html#method-i-primitive_errinfo">Encoding::Converter#primitive_errinfo</a>.</p>

<pre>ec = Encoding::Converter.new(&quot;utf-16le&quot;, &quot;iso-8859-1&quot;)
src = &quot;\x00\xd8\x61\x00&quot;
dst = &quot;&quot;
p ec.primitive_convert(src, dst)   #=&gt; :invalid_byte_sequence
p ec.primitive_errinfo     #=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;a\x00&quot;]
p ec.putback               #=&gt; &quot;a\x00&quot;
p ec.putback               #=&gt; &quot;&quot;          # no more bytes to put back</pre>
            

            
            <div class="method-source-code" id="putback-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_putback(int argc, VALUE *argv, VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    int n;
    int putbackable;
    VALUE str, max;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;max);

    if (NIL_P(max))
        n = rb_econv_putbackable(ec);
    else {
        n = NUM2INT(max);
        putbackable = rb_econv_putbackable(ec);
        if (putbackable &lt; n)
            n = putbackable;
    }

    str = rb_str_new(NULL, n);
    rb_econv_putback(ec, (unsigned char *)RSTRING_PTR(str), n);

    if (ec-&gt;source_encoding) {
        rb_enc_associate(str, ec-&gt;source_encoding);
    }

    return str;
}</code>
</pre> 
            </div><!-- putback-source -->
            
          </div>

          

          
        </div><!-- putback-method -->

      
        <div id="replacement-method" class="method-detail ">
          <a name="method-i-replacement"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replacement &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the replacement string.</p>

<pre>ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;us-ascii&quot;)
p ec.replacement    #=&gt; &quot;?&quot;

ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
p ec.replacement    #=&gt; &quot;\uFFFD&quot;</pre>
            

            
            <div class="method-source-code" id="replacement-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_get_replacement(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    int ret;
    rb_encoding *enc;

    ret = make_replacement(ec);
    if (ret == -1) {
        rb_raise(rb_eUndefinedConversionError, &quot;replacement character setup failed&quot;);
    }

    enc = rb_enc_find(ec-&gt;replacement_enc);
    return rb_enc_str_new((const char *)ec-&gt;replacement_str, (long)ec-&gt;replacement_len, enc);
}</code>
</pre> 
            </div><!-- replacement-source -->
            
          </div>

          

          
        </div><!-- replacement-method -->

      
        <div id="replacement-3D-method" class="method-detail ">
          <a name="method-i-replacement-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replacement = string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Sets the replacement string.</p>

<pre>ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;us-ascii&quot;, :undef =&gt; :replace)
ec.replacement = &quot;&lt;undef&gt;&quot;
p ec.convert(&quot;a \u3042 b&quot;)      #=&gt; &quot;a &lt;undef&gt; b&quot;</pre>
            

            
            <div class="method-source-code" id="replacement-3D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_set_replacement(VALUE self, VALUE arg)
{
    rb_econv_t *ec = check_econv(self);
    VALUE string = arg;
    int ret;
    rb_encoding *enc;

    StringValue(string);
    enc = rb_enc_get(string);

    ret = rb_econv_set_replacement(ec,
            (const unsigned char *)RSTRING_PTR(string),
            RSTRING_LEN(string),
            rb_enc_name(enc));

    if (ret == -1) {
        /* xxx: rb_eInvalidByteSequenceError? */
        rb_raise(rb_eUndefinedConversionError, &quot;replacement character setup failed&quot;);
    }

    return arg;
}</code>
</pre> 
            </div><!-- replacement-3D-source -->
            
          </div>

          

          
        </div><!-- replacement-3D-method -->

      
        <div id="source_encoding-method" class="method-detail ">
          <a name="method-i-source_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">source_encoding &rarr; encoding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the source encoding as an <a href="../Encoding.html">Encoding</a>
object.</p>
            

            
            <div class="method-source-code" id="source_encoding-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
econv_source_encoding(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    if (!ec-&gt;source_encoding)
        return Qnil;
    return rb_enc_from_encoding(ec-&gt;source_encoding);
}</code>
</pre> 
            </div><!-- source_encoding-source -->
            
          </div>

          

          
        </div><!-- source_encoding-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  

  </div><!-- documentation -->
<div id="disqus_thread" style='display:none'></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    // var disqus_shortname = 'rubydocbeta'; // required 
    var disqus_shortname = 'ruby-doc'; // required 
    
    var disqus_developer = true; // DEBUGGERY
    


    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink" style='display:none'>blog comments powered by <span class="logo-disqus">Disqus</span></a>

<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 1.9.2</small></p> 
  
   <p> <a href="http://www.ruby-doc.org">Ruby-doc.org</a> is hosted by <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>, an <a href="http://www.neurogami.com"> avant garage research + development in Scottsdale, AZ</a>.  </p>
 
    <p><small>Generated with the <a href="http://neurogami.com/code/">Rubydoc Rdoc Generator</a> 0.9.4</small>.</p>
  </div>

</div>

<script type="text/javascript">
var _uacct = "UA-335317-2";
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{ 
var pageTracker = _gat._getTracker(_uacct);
pageTracker._trackPageview();
} catch(err) {} 
</script>
</body>
</html>

