<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <!-- RD version: 0.9.4  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <title>Class: Regexp (Ruby 1.9.2) </title>
  <!-- raw_prefix  = '.'   -->
  <link rel="stylesheet" href="css/obf.css" >

  <script src="js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 
</head>

<body id="top" class="class">
<div id="actionbar" style='display:none' >
<div class='wrapper'>
<ul class='grids g0'>
  <li class='grid-2' ><a href='/' target='_top' >Home</a></li>
  <li class='grid-2' ><a href='/core' target='_top' >Core</a></li>
  <li class='grid-2' ><a href='/stdlib' target='_top' >Std-lib</a></li>
  <li class='grid-2' ><a href='/downloads' target='_top' >Downloads</a></li>
  <li class='grid-7 right' id='rd-action-search'><form id="searchbox_011815814100681837392:wnccv6st5qk" action="/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk" ><input name="q" type="text" size="20" >&#160;&#160;<input type="submit" name="sa" value="Search" ><input type="hidden" name="cof" value="FORID:9" ></form>
</li>
</ul>
</div>
</div> <!-- end action bar -->
          <div class='wrapper'>
  <div id="metadata" style='display:none'>
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="index.html">Home</a>
          <a href="index.html#classes">Classes</a>
          <a href="index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="re_c.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="re.c">re.c</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-compile">::compile</a></li>
          
          <li><a href="#method-c-escape">::escape</a></li>
          
          <li><a href="#method-c-last_match">::last_match</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-quote">::quote</a></li>
          
          <li><a href="#method-c-try_convert">::try_convert</a></li>
          
          <li><a href="#method-c-union">::union</a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-3D-3D-3D">#===</a></li>
          
          <li><a href="#method-i-3D-7E">#=~</a></li>
          
          <li><a href="#method-i-casefold-3F">#casefold?</a></li>
          
          <li><a href="#method-i-encoding">#encoding</a></li>
          
          <li><a href="#method-i-eql-3F">#eql?</a></li>
          
          <li><a href="#method-i-fixed_encoding-3F">#fixed_encoding?</a></li>
          
          <li><a href="#method-i-hash">#hash</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-match">#match</a></li>
          
          <li><a href="#method-i-named_captures">#named_captures</a></li>
          
          <li><a href="#method-i-names">#names</a></li>
          
          <li><a href="#method-i-options">#options</a></li>
          
          <li><a href="#method-i-source">#source</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-7E">#~</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="Encoding.html">Encoding</a></li>
        
          <li><a href="Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          <li><a href="Encoding/Converter.html">Encoding::Converter</a></li>
        
          <li><a href="Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          <li><a href="Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          <li><a href="Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          <li><a href="Process.html">Process</a></li>
        
          <li><a href="Process/GID.html">Process::GID</a></li>
        
          <li><a href="Process/Status.html">Process::Status</a></li>
        
          <li><a href="Process/Sys.html">Process::Sys</a></li>
        
          <li><a href="Process/UID.html">Process::UID</a></li>
        
          <li><a href="Enumerator.html">Enumerator</a></li>
        
          <li><a href="Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          <li><a href="Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          <li><a href="File.html">File</a></li>
        
          <li><a href="File/Constants.html">File::Constants</a></li>
        
          <li><a href="File/Stat.html">File::Stat</a></li>
        
          <li><a href="IO.html">IO</a></li>
        
          <li><a href="IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          <li><a href="IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          <li><a href="RubyVM.html">RubyVM</a></li>
        
          <li><a href="RubyVM/Env.html">RubyVM::Env</a></li>
        
          <li><a href="RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          <li><a href="GC.html">GC</a></li>
        
          <li><a href="GC/Profiler.html">GC::Profiler</a></li>
        
          <li><a href="Math.html">Math</a></li>
        
          <li><a href="Math/DomainError.html">Math::DomainError</a></li>
        
          <li><a href="NameError.html">NameError</a></li>
        
          <li><a href="NameError/message.html">NameError::message</a></li>
        
          <li><a href="ARGF.html">ARGF</a></li>
        
          <li><a href="ArgumentError.html">ArgumentError</a></li>
        
          <li><a href="Array.html">Array</a></li>
        
          <li><a href="BasicObject.html">BasicObject</a></li>
        
          <li><a href="Bignum.html">Bignum</a></li>
        
          <li><a href="Binding.html">Binding</a></li>
        
          <li><a href="Class.html">Class</a></li>
        
          <li><a href="Comparable.html">Comparable</a></li>
        
          <li><a href="Complex.html">Complex</a></li>
        
          <li><a href="Continuation.html">Continuation</a></li>
        
          <li><a href="Data.html">Data</a></li>
        
          <li><a href="Dir.html">Dir</a></li>
        
          <li><a href="EOFError.html">EOFError</a></li>
        
          <li><a href="EncodingError.html">EncodingError</a></li>
        
          <li><a href="Enumerable.html">Enumerable</a></li>
        
          <li><a href="Errno.html">Errno</a></li>
        
          <li><a href="Exception.html">Exception</a></li>
        
          <li><a href="FalseClass.html">FalseClass</a></li>
        
          <li><a href="Fiber.html">Fiber</a></li>
        
          <li><a href="FiberError.html">FiberError</a></li>
        
          <li><a href="FileTest.html">FileTest</a></li>
        
          <li><a href="Fixnum.html">Fixnum</a></li>
        
          <li><a href="Float.html">Float</a></li>
        
          <li><a href="FloatDomainError.html">FloatDomainError</a></li>
        
          <li><a href="Hash.html">Hash</a></li>
        
          <li><a href="IOError.html">IOError</a></li>
        
          <li><a href="IndexError.html">IndexError</a></li>
        
          <li><a href="Integer.html">Integer</a></li>
        
          <li><a href="Interrupt.html">Interrupt</a></li>
        
          <li><a href="Kernel.html">Kernel</a></li>
        
          <li><a href="KeyError.html">KeyError</a></li>
        
          <li><a href="LoadError.html">LoadError</a></li>
        
          <li><a href="LocalJumpError.html">LocalJumpError</a></li>
        
          <li><a href="Marshal.html">Marshal</a></li>
        
          <li><a href="MatchData.html">MatchData</a></li>
        
          <li><a href="Method.html">Method</a></li>
        
          <li><a href="Module.html">Module</a></li>
        
          <li><a href="Mutex.html">Mutex</a></li>
        
          <li><a href="NilClass.html">NilClass</a></li>
        
          <li><a href="NoMemoryError.html">NoMemoryError</a></li>
        
          <li><a href="NoMethodError.html">NoMethodError</a></li>
        
          <li><a href="NotImplementedError.html">NotImplementedError</a></li>
        
          <li><a href="Numeric.html">Numeric</a></li>
        
          <li><a href="Object.html">Object</a></li>
        
          <li><a href="ObjectSpace.html">ObjectSpace</a></li>
        
          <li><a href="Proc.html">Proc</a></li>
        
          <li><a href="Random.html">Random</a></li>
        
          <li><a href="Range.html">Range</a></li>
        
          <li><a href="RangeError.html">RangeError</a></li>
        
          <li><a href="Rational.html">Rational</a></li>
        
          <li><a href="Regexp.html">Regexp</a></li>
        
          <li><a href="RegexpError.html">RegexpError</a></li>
        
          <li><a href="RuntimeError.html">RuntimeError</a></li>
        
          <li><a href="ScriptError.html">ScriptError</a></li>
        
          <li><a href="SecurityError.html">SecurityError</a></li>
        
          <li><a href="Signal.html">Signal</a></li>
        
          <li><a href="SignalException.html">SignalException</a></li>
        
          <li><a href="StandardError.html">StandardError</a></li>
        
          <li><a href="StopIteration.html">StopIteration</a></li>
        
          <li><a href="String.html">String</a></li>
        
          <li><a href="Struct.html">Struct</a></li>
        
          <li><a href="Symbol.html">Symbol</a></li>
        
          <li><a href="SyntaxError.html">SyntaxError</a></li>
        
          <li><a href="SystemCallError.html">SystemCallError</a></li>
        
          <li><a href="SystemExit.html">SystemExit</a></li>
        
          <li><a href="SystemStackError.html">SystemStackError</a></li>
        
          <li><a href="Thread.html">Thread</a></li>
        
          <li><a href="ThreadError.html">ThreadError</a></li>
        
          <li><a href="ThreadGroup.html">ThreadGroup</a></li>
        
          <li><a href="Time.html">Time</a></li>
        
          <li><a href="TrueClass.html">TrueClass</a></li>
        
          <li><a href="TypeError.html">TypeError</a></li>
        
          <li><a href="UnboundMethod.html">UnboundMethod</a></li>
        
          <li><a href="ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          <li><a href="fatal.html">fatal</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation" style='margin: 10px 10px 10px 10px'>
    <h1 class="class">Regexp</h1>

    <div id="description" class="description">
      
<p>A <tt><a href="Regexp.html">Regexp</a></tt> holds a regular expression,
used to match a pattern against strings. Regexps are created using the
<tt>/.../</tt> and <tt>%r{...}</tt> literals, and by the <tt><a
href="Regexp.html#method-c-new">Regexp::new</a></tt> constructor.</p>

<p>Regular expressions (<em>regexp</em>s) are patterns which describe the
contents of a string. They’re used for testing whether a string contains a
given pattern, or extracting the portions that match. They are created with
the <tt>/</tt><em>pat</em><tt>/</tt> and <tt>%r{</tt><em>pat</em><tt>}</tt>
literals or the <tt><a href="Regexp.html#method-c-new">Regexp.new</a></tt>
constructor.</p>

<p>A regexp is usually delimited with forward slashes (<tt>/</tt>). For
example:</p>

<pre>/hay/ =~ 'haystack'   #=&gt; 0
/y/.match('haystack') #=&gt; #&lt;MatchData &quot;y&quot;&gt;</pre>

<p>If a string contains the pattern it is said to <em>match</em>. A literal
string matches itself.</p>

<pre># 'haystack' does not contain the pattern 'needle', so doesn't match.
/needle/.match('haystack') #=&gt; nil
# 'haystack' does contain the pattern 'hay', so it matches
/hay/.match('haystack')    #=&gt; #&lt;MatchData &quot;hay&quot;&gt;</pre>

<p>Specifically, <tt>/st/</tt> requires that the string contains the letter
<em>s</em> followed by the letter <em>t</em>, so it matches
<em>haystack</em>, also.</p>

<h2>Metacharacters and Escapes</h2>

<p>The following are <em>metacharacters</em> <tt>(</tt>, <tt>)</tt>,
<tt>[</tt>, <tt>]</tt>, <tt>{</tt>, <tt>}</tt>, <tt>.</tt>, <tt>?</tt>,
<tt>+</tt>, <tt>*</tt>. They have a specific meaning when appearing in a
pattern. To match them literally they must be backslash-escaped. To match a
backslash literally backslash-escape that: &lt;tt&gt;\\&lt;/tt&gt;.</p>

<pre>/1 \+ 2 = 3\?/.match('Does 1 + 2 = 3?') #=&gt; #&lt;MatchData &quot;1 + 2 = 3?&quot;&gt;</pre>

<p>Patterns behave like double-quoted strings so can contain the same
backslash escapes.</p>

<pre>/\s\u{6771 4eac 90fd}/.match(&quot;Go to 東京都&quot;)
    #=&gt; #&lt;MatchData &quot; 東京都&quot;&gt;</pre>

<p>Arbitrary Ruby expressions can be embedded into patterns with the
<tt>#{...}</tt> construct.</p>

<pre>place = &quot;東京都&quot;
/#{place}/.match(&quot;Go to 東京都&quot;)
    #=&gt; #&lt;MatchData &quot;東京都&quot;&gt;</pre>

<h2>Character Classes</h2>

<p>A <em>character class</em> is delimited with square brackets (<tt>[</tt>,
<tt>]</tt>) and lists characters that may appear at that point in the
match. <tt>/[ab]/</tt> means <em>a</em> or <em>b</em>, as opposed to
<tt>/ab/</tt> which means <em>a</em> followed by <em>b</em>.</p>

<pre>/W[aeiou]rd/.match(&quot;Word&quot;) #=&gt; #&lt;MatchData &quot;Word&quot;&gt;</pre>

<p>Within a character class the hyphen (<tt>-</tt>) is a metacharacter
denoting an inclusive range of characters. <tt>[abcd]</tt> is equivalent to
<tt>[a-d]</tt>. A range can be followed by another range, so
<tt>[abcdwxyz]</tt> is equivalent to <tt>[a-dw-z]</tt>. The order in which
ranges or individual characters appear inside a character class is
irrelevant.</p>

<pre>/[0-9a-f]/.match('9f') #=&gt; #&lt;MatchData &quot;9&quot;&gt;
/[9f]/.match('9f')     #=&gt; #&lt;MatchData &quot;9&quot;&gt;</pre>

<p>If the first character of a character class is a caret (<tt>^</tt>) the
class is inverted: it matches any character <em>except</em> those named.</p>

<pre>/[^a-eg-z]/.match('f') #=&gt; #&lt;MatchData &quot;f&quot;&gt;</pre>

<p>A character class may contain another character class. By itself this isn’t
useful because <tt>[<a href="http://0-9">a-z</a>]</tt> describes the same
set as <tt>[a-z0-9]</tt>. However, character classes also support the
<tt>&amp;&amp;</tt> operator which performs set intersection on its
arguments. The two can be combined as follows:</p>

<pre>/[a-w&amp;&amp;[^c-g]z]/ # ([a-w] AND ([^c-g] OR z))
# This is equivalent to:
/[abh-w]/</pre>

<p>The following metacharacters also behave like character classes:</p>
<ul><li>
<p><tt>/./</tt> - Any character except a newline.</p>
</li><li>
<p><tt>/./m</tt> - Any character (the <tt>m</tt> modifier enables multiline
mode)</p>
</li><li>
<p><tt>/\w/</tt> - A word character (<tt>[a-zA-Z0-9_]</tt>)</p>
</li><li>
<p><tt>/\W/</tt> - A non-word character (<tt>[^a-zA-Z0-9_]</tt>)</p>
</li><li>
<p><tt>/\d/</tt> - A digit character (<tt>[0-9]</tt>)</p>
</li><li>
<p><tt>/\D/</tt> - A non-digit character (<tt>[^0-9]</tt>)</p>
</li><li>
<p><tt>/\h/</tt> - A hexdigit character (<tt>[0-9a-fA-F]</tt>)</p>
</li><li>
<p><tt>/\H/</tt> - A non-hexdigit character (<tt>[^0-9a-fA-F]</tt>)</p>
</li><li>
<p><tt>/\s/</tt> - A whitespace character: <tt>/[ \t\r\n\f]/</tt></p>
</li><li>
<p><tt>/\S/</tt> - A non-whitespace character: <tt>/[^ \t\r\n\f]/</tt></p>
</li></ul>

<p>POSIX <em>bracket expressions</em> are also similar to character classes.
They provide a portable alternative to the above, with the added benefit
that they encompass non-ASCII characters. For instance, <tt>/\d/</tt>
matches only the ASCII decimal digits (0-9); whereas <tt>/[[:digit:]]/</tt>
matches any character in the Unicode <em>Nd</em> category.</p>
<ul><li>
<p><tt>/[[:alnum:]]/</tt> - Alphabetic and numeric character</p>
</li><li>
<p><tt>/[[:alpha:]]/</tt> - Alphabetic character</p>
</li><li>
<p><tt>/[[:blank:]]/</tt> - Space or tab</p>
</li><li>
<p><tt>/[[:cntrl:]]/</tt> - Control character</p>
</li><li>
<p><tt>/[[:digit:]]/</tt> - Digit</p>
</li><li>
<p><tt>/[[:graph:]]/</tt> - Non-blank character (excludes spaces, control
characters, and similar)</p>
</li><li>
<p><tt>/[[:lower:]]/</tt> - Lowercase alphabetical character</p>
</li><li>
<p><tt>/[[:print:]]/</tt> - Like [:graph:], but includes the space character</p>
</li><li>
<p><tt>/[[:punct:]]/</tt> - Punctuation character</p>
</li><li>
<p><tt>/[[:space:]]/</tt> - Whitespace character (<tt>[:blank:]</tt>, newline,</p>

<pre>carriage return, etc.)</pre>
</li><li>
<p><tt>/[[:upper:]]/</tt> - Uppercase alphabetical</p>
</li><li>
<p><tt>/[[:xdigit:]]/</tt> - Digit allowed in a hexadecimal number (i.e.,
0-9a-fA-F)</p>
</li></ul>

<p>Ruby also supports the following non-POSIX character classes:</p>
<ul><li>
<p><tt>/[[:word:]]/</tt> - A character in one of the following Unicode general
categories <em>Letter</em>, <em>Mark</em>, <em>Number</em>,
&lt;i&gt;Connector_Punctuation&lt;i/i&gt;</p>
</li><li>
<p><tt>/[[:ascii:]]/</tt> - A character in the ASCII character set</p>

<pre># U+06F2 is &quot;EXTENDED ARABIC-INDIC DIGIT TWO&quot;
/[[:digit:]]/.match(&quot;\u06F2&quot;)    #=&gt; #&lt;MatchData &quot;\u{06F2}&quot;&gt;
/[[:upper:]][[:lower:]]/.match(&quot;Hello&quot;) #=&gt; #&lt;MatchData &quot;He&quot;&gt;
/[[:xdigit:]][[:xdigit:]]/.match(&quot;A6&quot;)  #=&gt; #&lt;MatchData &quot;A6&quot;&gt;</pre>
</li></ul>

<h2>Repetition</h2>

<p>The constructs described so far match a single character. They can be
followed by a repetition metacharacter to specify how many times they need
to occur. Such metacharacters are called <em>quantifiers</em>.</p>
<ul><li>
<p><tt>*</tt> - Zero or more times</p>
</li><li>
<p><tt>+</tt> - One or more times</p>
</li><li>
<p><tt>?</tt> - Zero or one times (optional)</p>
</li><li>
<p><tt>{</tt><em>n</em><tt>}</tt> - Exactly <em>n</em> times</p>
</li><li>
<p><tt>{</tt><em>n</em><tt>,}</tt> - <em>n</em> or more times</p>
</li><li>
<p><tt>{,</tt><em>m</em><tt>}</tt> - <em>m</em> or less times</p>
</li><li>
<p><tt>{</tt><em>n</em><tt>,</tt><em>m</em><tt>}</tt> - At least <em>n</em>
and at most <em>m</em> times</p>

<pre># At least one uppercase character ('H'), at least one lowercase
# character ('e'), two 'l' characters, then one 'o'
&quot;Hello&quot;.match(/[[:upper:]]+[[:lower:]]+l{2}o/) #=&gt; #&lt;MatchData &quot;Hello&quot;&gt;</pre>
</li></ul>

<p>Repetition is <em>greedy</em> by default: as many occurrences as possible
are matched while still allowing the overall match to succeed. By contrast,
<em>lazy</em> matching makes the minimal amount of matches necessary for
overall success. A greedy metacharacter can be made lazy by following it
with <tt>?</tt>.</p>

<pre># Both patterns below match the string. The first uses a greedy
# quantifier so '.+' matches '&lt;a&gt;&lt;b&gt;'; the second uses a lazy
# quantifier so '.+?' matches '&lt;a&gt;'.
/&lt;.+&gt;/.match(&quot;&lt;a&gt;&lt;b&gt;&quot;)  #=&gt; #&lt;MatchData &quot;&lt;a&gt;&lt;b&gt;&quot;&gt;
/&lt;.+?&gt;/.match(&quot;&lt;a&gt;&lt;b&gt;&quot;) #=&gt; #&lt;MatchData &quot;&lt;a&gt;&quot;&gt;</pre>

<p>A quantifier followed by <tt>+</tt> matches <em>possessively</em>: once it
has matched it does not backtrack. They behave like greedy quantifiers, but
having matched they refuse to “give up” their match even if this
jeopardises the overall match.</p>

<h2>Capturing</h2>

<p>Parentheses can be used for <em>capturing</em>. The text enclosed by the
<em>n</em>&lt;sup&gt;th&lt;/sup&gt; group of parentheses can be
subsequently referred to with <em>n</em>. Within a pattern use the
<em>backreference</em> <tt>&lt;/tt&gt;<em>n</em>; outside of the pattern
use &lt;<a href="http://n">tt>MatchData</a></tt>.</p>

<pre># 'at' is captured by the first group of parentheses, then referred to
# later with \1
/[csh](..) [csh]\1 in/.match(&quot;The cat sat in the hat&quot;)
    #=&gt; #&lt;MatchData &quot;cat sat in&quot; 1:&quot;at&quot;&gt;
# Regexp#match returns a MatchData object which makes the captured
# text available with its #[] method.
/[csh](..) [csh]\1 in/.match(&quot;The cat sat in the hat&quot;)[1] #=&gt; 'at'</pre>

<p>Capture groups can be referred to by name when defined with the
<tt>(?&lt;</tt><em>name</em><tt>&gt;)</tt> or
<tt>(?'</tt><em>name</em><tt>')</tt> constructs.</p>

<pre>/\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)/.match(&quot;$3.67&quot;)
    =&gt; #&lt;MatchData &quot;$3.67&quot; dollars:&quot;3&quot; cents:&quot;67&quot;&gt;
/\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)/.match(&quot;$3.67&quot;)[:dollars] #=&gt; &quot;3&quot;</pre>

<p>Named groups can be backreferenced with
<tt>\k&lt;</tt><em>name</em><tt>&gt;</tt>, where <em>name</em> is the group
name.</p>

<pre>/(?&lt;vowel&gt;[aeiou]).\k&lt;vowel&gt;.\k&lt;vowel&gt;/.match('ototomy')
    #=&gt; #&lt;MatchData &quot;ototo&quot; vowel:&quot;o&quot;&gt;</pre>

<p><b>Note</b>: A regexp can't use named backreferences and numbered
backreferences simultaneously.</p>

<p>When named capture groups are used with a literal regexp on the left-hand
side of an expression and the <tt>=~</tt> operator, the captured text is
also assigned to local variables with corresponding names.</p>

<pre>/\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)/ =~ &quot;$3.67&quot; #=&gt; 0
dollars #=&gt; &quot;3&quot;</pre>

<h2>Grouping</h2>

<p>Parentheses also <em>group</em> the terms they enclose, allowing them to be
quantified as one <em>atomic</em> whole.</p>

<pre># The pattern below matches a vowel followed by 2 word characters:
# 'aen'
/[aeiou]\w{2}/.match(&quot;Caenorhabditis elegans&quot;) #=&gt; #&lt;MatchData &quot;aen&quot;&gt;
# Whereas the following pattern matches a vowel followed by a word
# character, twice, i.e. &lt;tt&gt;[aeiou]\w[aeiou]\w&lt;/tt&gt;: 'enor'.
/([aeiou]\w){2}/.match(&quot;Caenorhabditis elegans&quot;)
    #=&gt; #&lt;MatchData &quot;enor&quot; 1:&quot;or&quot;&gt;</pre>

<p>The <tt>(?:</tt>…<tt>)</tt> construct provides grouping without capturing.
That is, it combines the terms it contains into an atomic whole without
creating a backreference. This benefits performance at the slight expense
of readabilty.</p>

<pre># The group of parentheses captures 'n' and the second 'ti'. The
# second group is referred to later with the backreference \2
/I(n)ves(ti)ga\2ons/.match(&quot;Investigations&quot;)
    #=&gt; #&lt;MatchData &quot;Investigations&quot; 1:&quot;n&quot; 2:&quot;ti&quot;&gt;
# The first group of parentheses is now made non-capturing with '?:',
# so it still matches 'n', but doesn't create the backreference. Thus,
# the backreference \1 now refers to 'ti'.
/I(?:n)ves(ti)ga\1ons/.match(&quot;Investigations&quot;)
    #=&gt; #&lt;MatchData &quot;Investigations&quot; 1:&quot;ti&quot;&gt;</pre>

<h3>Atomic Grouping</h3>

<p>Grouping can be made <em>atomic</em> with
<tt>(?&gt;</tt><em>pat</em><tt>)</tt>. This causes the subexpression
<em>pat</em> to be matched independently of the rest of the expression such
that what it matches becomes fixed for the remainder of the match, unless
the entire subexpression must be abandoned and subsequently revisited. In
this way <em>pat</em> is treated as a non-divisible whole. Atomic grouping
is typically used to optimise patterns so as to prevent the regular
expression engine from backtracking needlesly.</p>

<pre># The &lt;tt&gt;&quot;&lt;/tt&gt; in the pattern below matches the first character of
# the string, then &lt;tt&gt;.*&lt;/tt&gt; matches &lt;i&gt;Quote&quot;&lt;/i&gt;. This causes the
# overall match to fail, so the text matched by &lt;tt&gt;.*&lt;/tt&gt; is
# backtracked by one position, which leaves the final character of the
# string available to match &lt;tt&gt;&quot;&lt;/tt&gt;
      /&quot;.*&quot;/.match('&quot;Quote&quot;')     #=&gt; #&lt;MatchData &quot;\&quot;Quote\&quot;&quot;&gt;
# If &lt;tt&gt;.*&lt;/tt&gt; is grouped atomically, it refuses to backtrack
# &lt;i&gt;Quote&quot;&lt;/i&gt;, even though this means that the overall match fails
/&quot;(?&gt;.*)&quot;/.match('&quot;Quote&quot;') #=&gt; nil</pre>

<h2>Subexpression Calls</h2>

<p>The <tt>\g&lt;</tt><em>name</em><tt>&gt;</tt> syntax matches the previous
subexpression named <em>name</em>, which can be a group name or number,
again. This differs from backreferences in that it re-executes the group
rather than simply trying to re-match the same text.</p>

<pre># Matches a &lt;i&gt;(&lt;/i&gt; character and assigns it to the &lt;tt&gt;paren&lt;/tt&gt;
# group, tries to call that the &lt;tt&gt;paren&lt;/tt&gt; sub-expression again
# but fails, then matches a literal &lt;i&gt;)&lt;/i&gt;.
/\A(?&lt;paren&gt;\(\g&lt;paren&gt;*\))*\z/ =~ '()'

/\A(?&lt;paren&gt;\(\g&lt;paren&gt;*\))*\z/ =~ '(())' #=&gt; 0
# ^1
#      ^2
#           ^3
#                 ^4
#      ^5
#           ^6
#                      ^7
#                       ^8
#                       ^9
#                           ^10</pre>
<ol><li>
<p>Matches at the beginning of the string, i.e. before the first character.</p>
</li><li>
<p>Enters a named capture group called <tt>paren</tt></p>
</li><li>
<p>Matches a literal <em>(</em>, the first character in the string</p>
</li><li>
<p>Calls the <tt>paren</tt> group again, i.e. recurses back to the second step</p>
</li><li>
<p>Re-enters the <tt>paren</tt> group</p>
</li><li>
<p>Matches a literal <em>(</em>, the second character in the string</p>
</li><li>
<p>Try to call <tt>paren</tt> a third time, but fail because doing so would
prevent an overall successful match</p>
</li><li>
<p>Match a literal <em>)</em>, the third character in the string. Marks the
end of the second recursive call</p>
</li><li>
<p>Match a literal <em>)</em>, the fourth character in the string</p>
</li><li>
<p>Match the end of the string</p>
</li></ol>

<h2>Alternation</h2>

<p>The vertical bar metacharacter (<tt>|</tt>) combines two expressions into a
single one that matches either of the expressions. Each expression is an
<em>alternative</em>.</p>

<pre>/\w(and|or)\w/.match(&quot;Feliformia&quot;) #=&gt; #&lt;MatchData &quot;form&quot; 1:&quot;or&quot;&gt;
/\w(and|or)\w/.match(&quot;furandi&quot;)    #=&gt; #&lt;MatchData &quot;randi&quot; 1:&quot;and&quot;&gt;
/\w(and|or)\w/.match(&quot;dissemblance&quot;) #=&gt; nil</pre>

<h2>Character Properties</h2>

<p>The <tt>\p{}</tt> construct matches characters with the named property,
much like POSIX bracket classes.</p>
<ul><li>
<p><tt>/\p{Alnum}/</tt> - Alphabetic and numeric character</p>
</li><li>
<p><tt>/\p{Alpha}/</tt> - Alphabetic character</p>
</li><li>
<p><tt>/\p{Blank}/</tt> - Space or tab</p>
</li><li>
<p><tt>/\p{Cntrl}/</tt> - Control character</p>
</li><li>
<p><tt>/\p{Digit}/</tt> - Digit</p>
</li><li>
<p><tt>/\p{Graph}/</tt> - Non-blank character (excludes spaces, control
characters, and similar)</p>
</li><li>
<p><tt>/\p{Lower}/</tt> - Lowercase alphabetical character</p>
</li><li>
<p><tt>/\p{Print}/</tt> - Like <tt>\p{Graph}</tt>, but includes the space
character</p>
</li><li>
<p><tt>/\p{Punct}/</tt> - Punctuation character</p>
</li><li>
<p><tt>/\p{Space}/</tt> - Whitespace character (<tt>[:blank:]</tt>, newline,
carriage return, etc.)</p>
</li><li>
<p><tt>/\p{Upper}/</tt> - Uppercase alphabetical</p>
</li><li>
<p><tt>/\p{XDigit}/</tt> - Digit allowed in a hexadecimal number (i.e.,
0-9a-fA-F)</p>
</li><li>
<p><tt>/\p{Word}/</tt> - A member of one of the following Unicode general
category <em>Letter</em>, <em>Mark</em>, <em>Number</em>,
<em>Connector_Punctuation</em></p>
</li><li>
<p><tt>/\p{ASCII}/</tt> - A character in the ASCII character set</p>
</li><li>
<p><tt>/\p{Any}/</tt> - Any Unicode character (including unassigned
characters)</p>
</li><li>
<p><tt>/\p{Assigned}/</tt> - An assigned character</p>
</li></ul>

<p>A Unicode character’s <em>General Category</em> value can also be matched
with <tt>\p{</tt><em>Ab</em><tt>}</tt> where <em>Ab</em> is the category’s
abbreviation as described below:</p>
<ul><li>
<p><tt>/\p{L}/</tt> - 'Letter'</p>
</li><li>
<p><tt>/\p{Ll}/</tt> - 'Letter: Lowercase'</p>
</li><li>
<p><tt>/\p{Lm}/</tt> - 'Letter: Mark'</p>
</li><li>
<p><tt>/\p{Lo}/</tt> - 'Letter: Other'</p>
</li><li>
<p><tt>/\p{Lt}/</tt> - 'Letter: Titlecase'</p>
</li><li>
<p><tt>/\p{Lu}/</tt> - 'Letter: Uppercase</p>
</li><li>
<p><tt>/\p{Lo}/</tt> - 'Letter: Other'</p>
</li><li>
<p><tt>/\p{M}/</tt> - 'Mark'</p>
</li><li>
<p><tt>/\p{Mn}/</tt> - 'Mark: Nonspacing'</p>
</li><li>
<p><tt>/\p{Mc}/</tt> - 'Mark: Spacing Combining'</p>
</li><li>
<p><tt>/\p{Me}/</tt> - 'Mark: Enclosing'</p>
</li><li>
<p><tt>/\p{N}/</tt> - 'Number'</p>
</li><li>
<p><tt>/\p{Nd}/</tt> - 'Number: Decimal Digit'</p>
</li><li>
<p><tt>/\p{Nl}/</tt> - 'Number: Letter'</p>
</li><li>
<p><tt>/\p{No}/</tt> - 'Number: Other'</p>
</li><li>
<p><tt>/\p{P}/</tt> - 'Punctuation'</p>
</li><li>
<p><tt>/\p{Pc}/</tt> - 'Punctuation: Connector'</p>
</li><li>
<p><tt>/\p{Pd}/</tt> - 'Punctuation: Dash'</p>
</li><li>
<p><tt>/\p{Ps}/</tt> - 'Punctuation: Open'</p>
</li><li>
<p><tt>/\p{Pe}/</tt> - 'Punctuation: Close'</p>
</li><li>
<p><tt>/\p{Pi}/</tt> - 'Punctuation: Initial Quote'</p>
</li><li>
<p><tt>/\p{Pf}/</tt> - 'Punctuation: Final Quote'</p>
</li><li>
<p><tt>/\p{Po}/</tt> - 'Punctuation: Other'</p>
</li><li>
<p><tt>/\p{S}/</tt> - 'Symbol'</p>
</li><li>
<p><tt>/\p{Sm}/</tt> - 'Symbol: Math'</p>
</li><li>
<p><tt>/\p{Sc}/</tt> - 'Symbol: Currency'</p>
</li><li>
<p><tt>/\p{Sc}/</tt> - 'Symbol: Currency'</p>
</li><li>
<p><tt>/\p{Sk}/</tt> - 'Symbol: Modifier'</p>
</li><li>
<p><tt>/\p{So}/</tt> - 'Symbol: Other'</p>
</li><li>
<p><tt>/\p{Z}/</tt> - 'Separator'</p>
</li><li>
<p><tt>/\p{Zs}/</tt> - 'Separator: Space'</p>
</li><li>
<p><tt>/\p{Zl}/</tt> - 'Separator: Line'</p>
</li><li>
<p><tt>/\p{Zp}/</tt> - 'Separator: Paragraph'</p>
</li><li>
<p><tt>/\p{C}/</tt> - 'Other'</p>
</li><li>
<p><tt>/\p{Cc}/</tt> - 'Other: Control'</p>
</li><li>
<p><tt>/\p{Cf}/</tt> - 'Other: Format'</p>
</li><li>
<p><tt>/\p{Cn}/</tt> - 'Other: Not Assigned'</p>
</li><li>
<p><tt>/\p{Co}/</tt> - 'Other: Private Use'</p>
</li><li>
<p><tt>/\p{Cs}/</tt> - 'Other: Surrogate'</p>
</li></ul>

<p>Lastly, <tt>\p{}</tt> matches a character’s Unicode <em>script</em>. The
following scripts are supported: <em>Arabic</em>, <em>Armenian</em>,
<em>Balinese</em>, <em>Bengali</em>, <em>Bopomofo</em>, <em>Braille</em>,
<em>Buginese</em>, <em>Buhid</em>, <em>Canadian_Aboriginal</em>,
<em>Carian</em>, <em>Cham</em>, <em>Cherokee</em>, <em>Common</em>,
<em>Coptic</em>, <em>Cuneiform</em>, <em>Cypriot</em>, <em>Cyrillic</em>,
<em>Deseret</em>, <em>Devanagari</em>, <em>Ethiopic</em>,
<em>Georgian</em>, <em>Glagolitic</em>, <em>Gothic</em>, <em>Greek</em>,
<em>Gujarati</em>, <em>Gurmukhi</em>, <em>Han</em>, <em>Hangul</em>,
<em>Hanunoo</em>, <em>Hebrew</em>, <em>Hiragana</em>, <em>Inherited</em>,
<em>Kannada</em>, <em>Katakana</em>, <em>Kayah_Li</em>,
<em>Kharoshthi</em>, <em>Khmer</em>, <em>Lao</em>, <em>Latin</em>,
<em>Lepcha</em>, <em>Limbu</em>, <em>Linear_B</em>, <em>Lycian</em>,
<em>Lydian</em>, <em>Malayalam</em>, <em>Mongolian</em>, <em>Myanmar</em>,
<em>New_Tai_Lue</em>, <em>Nko</em>, <em>Ogham</em>, <em>Ol_Chiki</em>,
<em>Old_Italic</em>, <em>Old_Persian</em>, <em>Oriya</em>,
<em>Osmanya</em>, <em>Phags_Pa</em>, <em>Phoenician</em>, <em>Rejang</em>,
<em>Runic</em>, <em>Saurashtra</em>, <em>Shavian</em>, <em>Sinhala</em>,
<em>Sundanese</em>, <em>Syloti_Nagri</em>, <em>Syriac</em>,
<em>Tagalog</em>, <em>Tagbanwa</em>, <em>Tai_Le</em>, <em>Tamil</em>,
<em>Telugu</em>, <em>Thaana</em>, <em>Thai</em>, <em>Tibetan</em>,
<em>Tifinagh</em>, <em>Ugaritic</em>, <em>Vai</em>, and <em>Yi</em>.</p>

<pre># Unicode codepoint U+06E9 is named &quot;ARABIC PLACE OF SAJDAH&quot; and
# belongs to the Arabic script.
/\p{Arabic}/.match(&quot;\u06E9&quot;) #=&gt; #&lt;MatchData &quot;\u06E9&quot;&gt;</pre>

<p>All character properties can be inverted by prefixing their name with a
caret (<tt>^</tt>).</p>

<pre># Letter 'A' is not in the Unicode Ll (Letter; Lowercase) category, so
# this match succeeds
/\p{^Ll}/.match(&quot;A&quot;) #=&gt; #&lt;MatchData &quot;A&quot;&gt;</pre>

<h2>Anchors</h2>

<p>Anchors are metacharacter that match the zero-width positions between
characters, <em>anchoring</em> the match to a specific position.</p>
<ul><li>
<p><tt>^</tt> - Matches beginning of line</p>
</li><li>
<p><tt>$</tt> - Matches end of line</p>
</li><li>
<p><tt>\A</tt> - Matches beginning of string.</p>
</li><li>
<p><tt>\Z</tt> - Matches end of string. If string ends with a newline, it
matches just before newline</p>
</li><li>
<p><tt>\z</tt> - Matches end of string</p>
</li><li>
<p><tt>\G</tt> - Matches point where last match finished</p>
</li><li>
<p><tt>\b</tt> - Matches word boundaries when outside brackets; backspace</p>

<pre>(0x08) inside brackets</pre>
</li><li>
<p><tt>\B</tt> - Matches non-word boundaries</p>
</li><li>
<p><tt>(?=</tt><em>pat</em><tt>)</tt> - <em>Positive lookahead</em> assertion:
ensures that the following characters match <em>pat</em>, but doesn't
include those characters in the matched text</p>
</li><li>
<p><tt>(?!</tt><em>pat</em><tt>)</tt> - <em>Negative lookahead</em> assertion:
ensures that the following characters do not match <em>pat</em>, but
doesn't include those characters in the matched text</p>
</li><li>
<p><tt>(?&lt;=</tt><em>pat</em><tt>)</tt> - <em>Positive lookbehind</em>
assertion: ensures that the preceding characters match <em>pat</em>, but
doesn't include those characters in the matched text</p>
</li><li>
<p><tt>(?&lt;!</tt><em>pat</em><tt>)</tt> - <em>Negative lookbehind</em>
assertion: ensures that the preceding characters do not match <em>pat</em>,
but doesn't include those characters in the matched text</p>

<pre># If a pattern isn't anchored it can begin at any point in the string
/real/.match(&quot;surrealist&quot;) #=&gt; #&lt;MatchData &quot;real&quot;&gt;
# Anchoring the pattern to the beginning of the string forces the
# match to start there. 'real' doesn't occur at the beginning of the
# string, so now the match fails
/\Areal/.match(&quot;surrealist&quot;) #=&gt; nil
# The match below fails because although 'Demand' contains 'and', the
pattern does not occur at a word boundary.
/\band/.match(&quot;Demand&quot;)
# Whereas in the following example 'and' has been anchored to a
# non-word boundary so instead of matching the first 'and' it matches
# from the fourth letter of 'demand' instead
/\Band.+/.match(&quot;Supply and demand curve&quot;) #=&gt; #&lt;MatchData &quot;and curve&quot;&gt;
# The pattern below uses positive lookahead and positive lookbehind to
# match text appearing in &lt;b&gt;&lt;/b&gt; tags without including the tags in the
# match
/(?&lt;=&lt;b&gt;)\w+(?=&lt;\/b&gt;)/.match(&quot;Fortune favours the &lt;b&gt;bold&lt;/b&gt;&quot;)
    #=&gt; #&lt;MatchData &quot;bold&quot;&gt;</pre>
</li></ul>

<h2>Options</h2>

<p>The end delimiter for a regexp can be followed by one or more single-letter
options which control how the pattern can match.</p>
<ul><li>
<p><tt>/pat/i</tt> - Ignore case</p>
</li><li>
<p><tt>/pat/m</tt> - Treat a newline as a character matched by <tt>.</tt></p>
</li><li>
<p><tt>/pat/x</tt> - Ignore whitespace and comments in the pattern</p>
</li><li>
<p><tt>/pat/o</tt> - Perform <tt>#{}</tt> interpolation only once</p>
</li></ul>

<p><tt>i</tt>, <tt>m</tt>, and <tt>x</tt> can also be applied on the
subexpression level with the
<tt>(?</tt><em>on</em><tt>-</tt><em>off</em><tt>)</tt> construct, which
enables options <em>on</em>, and disables options <em>off</em> for the
expression enclosed by the parentheses.</p>

<pre>/a(?i:b)c/.match('aBc') #=&gt; #&lt;MatchData &quot;aBc&quot;&gt;
/a(?i:b)c/.match('abc') #=&gt; #&lt;MatchData &quot;abc&quot;&gt;</pre>

<h2>Free-Spacing Mode and Comments</h2>

<p>As mentioned above, the <tt>x</tt> option enables <em>free-spacing</em>
mode. Literal white space inside the pattern is ignored, and the octothorpe
(<tt>#</tt>) character introduces a comment until the end of the line. This
allows the components of the pattern to be organised in a potentially more
readable fashion.</p>

<pre># A contrived pattern to match a number with optional decimal places
float_pat = /\A
    [[:digit:]]+ # 1 or more digits before the decimal point
    (\.          # Decimal point
        [[:digit:]]+ # 1 or more digits after the decimal point
    )? # The decimal point and following digits are optional
\Z/x
float_pat.match('3.14') #=&gt; #&lt;MatchData &quot;3.14&quot; 1:&quot;.14&quot;&gt;</pre>

<p><b>Note</b>: To match whitespace in an <tt>x</tt> pattern use an escape
such as <tt>\s</tt> or <tt>\p{Space}</tt>.</p>

<p>Comments can be included in a non-<tt>x</tt> pattern with the
<tt>(?#</tt><em>comment</em><tt>)</tt> construct, where <em>comment</em> is
arbitrary text ignored by the regexp engine.</p>

<h2><a href="Encoding.html">Encoding</a></h2>

<p>Regular expressions are assumed to use the source encoding. This can be
overridden with one of the following modifiers.</p>
<ul><li>
<p><tt>/</tt><em>pat</em><tt>/u</tt> - UTF-8</p>
</li><li>
<p><tt>/</tt><em>pat</em><tt>/e</tt> - EUC-JP</p>
</li><li>
<p><tt>/</tt><em>pat</em><tt>/s</tt> - Windows-31J</p>
</li><li>
<p><tt>/</tt><em>pat</em><tt>/n</tt> - ASCII-8BIT</p>
</li></ul>

<p>A regexp can be matched against a string when they either share an
encoding, or the regexp’s encoding is <em>US-ASCII</em> and the string’s
encoding is ASCII-compatible.</p>

<p>If a match between incompatible encodings is attempted an <tt><a
href="Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></tt>
exception is raised.</p>

<p>The <tt><a
href="Regexp.html#method-i-fixed_encoding-3F">Regexp#fixed_encoding?</a></tt>
predicate indicates whether the regexp has a <em>fixed</em> encoding, that
is one incompatible with ASCII. A regexp’s encoding can be explicitly fixed
by supplying <tt>Regexp::FIXEDENCODING</tt> as the second argument of
<tt><a href="Regexp.html#method-c-new">Regexp.new</a></tt>:</p>

<pre>r = Regexp.new(&quot;a&quot;.force_encoding(&quot;iso-8859-1&quot;),Regexp::FIXEDENCODING)
r =~&quot;a\u3042&quot;
   #=&gt; Encoding::CompatibilityError: incompatible encoding regexp match
        (ISO-8859-1 regexp with UTF-8 string)</pre>

<h2>Performance</h2>

<p>Certain pathological combinations of constructs can lead to abysmally bad
performance.</p>

<p>Consider a string of 25 <em>a</em>s, a <em>d</em>, 4 <em>a</em>s, and a
<em>c</em>.</p>

<pre>s = 'a' * 25 + 'd' 'a' * 4 + 'c'
    #=&gt; &quot;aaaaaaaaaaaaaaaaaaaaaaaaadadadadac&quot;</pre>

<p>The following patterns match instantly as you would expect:</p>

<pre>/(b|a)/ =~ s #=&gt; 0
/(b|a+)/ =~ s #=&gt; 0
/(b|a+)*\/ =~ s #=&gt; 0</pre>

<p>However, the following pattern takes appreciably longer:</p>

<pre>/(b|a+)*c/ =~ s #=&gt; 32</pre>

<p>This happens because an atom in the regexp is quantified by both an
immediate <tt>+</tt> and an enclosing <tt>*</tt> with nothing to
differentiate which is in control of any particular character. The
nondeterminism that results produces super-linear performance. (Consult
<em>Mastering Regular Expressions</em> (3rd ed.), pp 222, by <em>Jeffery
Friedl</em>, for an in-depth analysis). This particular case can be fixed
by use of atomic grouping, which prevents the unnecessary backtracking:</p>

<pre>(start = Time.now) &amp;&amp; /(b|a+)*c/ =~ s &amp;&amp; (Time.now - start)
   #=&gt; 24.702736882
(start = Time.now) &amp;&amp; /(?&gt;b|a+)*c/ =~ s &amp;&amp; (Time.now - start)
   #=&gt; 0.000166571</pre>

<p>A similar case is typified by the following example, which takes
approximately 60 seconds to execute for me:</p>

<pre># Match a string of 29 &lt;i&gt;a&lt;/i&gt;s against a pattern of 29 optional
# &lt;i&gt;a&lt;/i&gt;s followed by 29 mandatory &lt;i&gt;a&lt;/i&gt;s.
Regexp.new('a?' * 29 + 'a' * 29) =~ 'a' * 29</pre>

<p>The 29 optional <em>a</em>s match the string, but this prevents the 29
mandatory <em>a</em>s that follow from matching. Ruby must then backtrack
repeatedly so as to satisfy as many of the optional matches as it can while
still matching the mandatory 29. It is plain to us that none of the
optional matches can succeed, but this fact unfortunately eludes Ruby.</p>

<p>One approach for improving performance is to anchor the match to the
beginning of the string, thus significantly reducing the amount of
backtracking needed.</p>

<pre>Regexp.new('\A' 'a?' * 29 + 'a' * 29).match('a' * 29)
    #=&gt; #&lt;MatchData &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;&gt;</pre>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="EXTENDED">EXTENDED</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FIXEDENCODING">FIXEDENCODING</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="IGNORECASE">IGNORECASE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="MULTILINE">MULTILINE</a></dt>
          
          <dd class="description"></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="compile-method" class="method-detail ">
          <a name="method-c-compile"></a>

          
          <div class="method-heading">
            <span class="method-name">compile</span><span
              class="method-args">(*args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Synonym for <tt><a href="Regexp.html#method-c-new">Regexp.new</a></tt></p>
            

            
          </div>

          

          
        </div><!-- compile-method -->

      
        <div id="escape-method" class="method-detail ">
          <a name="method-c-escape"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">escape(str)   &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">quote(str)    &rarr; string</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string, or self if no characters are
escaped.  For any string, <tt><a
href="Regexp.html#method-c-new">Regexp.new</a>(<a
href="Regexp.html#method-c-escape">Regexp.escape</a>(<em>str</em>))=~<em>str</em></tt>
will be true.</p>

<pre>Regexp.escape('\*?{}.')   #=&gt; \\\*\?\{\}\.</pre>
            

            
            <div class="method-source-code" id="escape-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_s_quote(VALUE c, VALUE str)
{
    return rb_reg_quote(reg_operand(str, TRUE));
}</code>
</pre> 
            </div><!-- escape-source -->
            
          </div>

          

          
        </div><!-- escape-method -->

      
        <div id="last_match-method" class="method-detail ">
          <a name="method-c-last_match"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">last_match           &rarr; matchdata</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">last_match(n)        &rarr; str</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>The first form returns the <tt><a href="MatchData.html">MatchData</a></tt>
object generated by the last successful pattern match. Equivalent to
reading the global variable <tt>$~</tt>. The second form returns the
<em>n</em>th field in this <tt><a href="MatchData.html">MatchData</a></tt>
object. <em>n</em> can be a string or symbol to reference a named capture.</p>

<p>Note that the <tt><a
href="Regexp.html#method-c-last_match">last_match</a></tt> is local to the
thread and method scope of the method that did the pattern match.</p>

<pre>/c(.)t/ =~ 'cat'        #=&gt; 0
Regexp.last_match       #=&gt; #&lt;MatchData &quot;cat&quot; 1:&quot;a&quot;&gt;
Regexp.last_match(0)    #=&gt; &quot;cat&quot;
Regexp.last_match(1)    #=&gt; &quot;a&quot;
Regexp.last_match(2)    #=&gt; nil

/(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;var = val&quot;
Regexp.last_match       #=&gt; #&lt;MatchData &quot;var = val&quot; lhs:&quot;var&quot; rhs:&quot;val&quot;&gt;
Regexp.last_match(:lhs) #=&gt; &quot;var&quot;
Regexp.last_match(:rhs) #=&gt; &quot;val&quot;</pre>
            

            
            <div class="method-source-code" id="last_match-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_s_last_match(int argc, VALUE *argv)
{
    VALUE nth;

    if (argc &gt; 0 &amp;&amp; rb_scan_args(argc, argv, &quot;01&quot;, &amp;nth) == 1) {
        VALUE match = rb_backref_get();
        int n;
        if (NIL_P(match)) return Qnil;
        n = match_backref_number(match, nth);
        return rb_reg_nth_match(n, match);
    }
    return match_getter();
}</code>
</pre> 
            </div><!-- last_match-source -->
            
          </div>

          

          
        </div><!-- last_match-method -->

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new(string, [options [, lang]])        &rarr; regexp</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new(regexp)                            &rarr; regexp</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">compile(string, [options [, lang]])    &rarr; regexp</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">compile(regexp)                        &rarr; regexp</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Constructs a new regular expression from <em>pattern</em>, which can be
either a <tt><a href="String.html">String</a></tt> or a <tt><a
href="Regexp.html">Regexp</a></tt> (in which case that regexp’s options are
propagated, and new options may not be specified (a change as of Ruby 1.8).
If <em>options</em> is a <tt><a href="Fixnum.html">Fixnum</a></tt>, it
should be one or more of the constants <tt>Regexp::EXTENDED</tt>,
<tt>Regexp::IGNORECASE</tt>, and <tt>Regexp::MULTILINE</tt>, <em>or</em>-ed
together. Otherwise, if <em>options</em> is not <tt>nil</tt>, the regexp
will be case insensitive. When the <em>lang</em> parameter is `n’ or `N’
sets the regexp no encoding.</p>

<pre>r1 = Regexp.new('^a-z+:\\s+\w+')           #=&gt; /^a-z+:\s+\w+/
r2 = Regexp.new('cat', true)               #=&gt; /cat/i
r3 = Regexp.new('dog', Regexp::EXTENDED)   #=&gt; /dog/x
r4 = Regexp.new(r2)                        #=&gt; /cat/i</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_initialize_m(int argc, VALUE *argv, VALUE self)
{
    onig_errmsg_buffer err = &quot;&quot;;
    int flags = 0;
    VALUE str;
    rb_encoding *enc;
    const char *ptr;
    long len;

    if (argc == 0 || argc &gt; 3) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1..3)&quot;, argc);
    }
    if (TYPE(argv[0]) == T_REGEXP) {
        VALUE re = argv[0];

        if (argc &gt; 1) {
            rb_warn(&quot;flags ignored&quot;);
        }
        rb_reg_check(re);
        flags = rb_reg_options(re);
        ptr = RREGEXP_SRC_PTR(re);
        len = RREGEXP_SRC_LEN(re);
        enc = rb_enc_get(re);
        if (rb_reg_initialize(self, ptr, len, enc, flags, err, NULL, 0)) {
            str = rb_enc_str_new(ptr, len, enc);
            rb_reg_raise_str(str, flags, err);
        }
    }
    else {
        if (argc &gt;= 2) {
            if (FIXNUM_P(argv[1])) flags = FIX2INT(argv[1]);
            else if (RTEST(argv[1])) flags = ONIG_OPTION_IGNORECASE;
        }
        enc = 0;
        if (argc == 3 &amp;&amp; !NIL_P(argv[2])) {
            char *kcode = StringValuePtr(argv[2]);
            if (kcode[0] == 'n' || kcode[0] == 'N') {
                enc = rb_ascii8bit_encoding();
                flags |= ARG_ENCODING_NONE;
            }
            else {
                rb_warn(&quot;encoding option is ignored - %s&quot;, kcode);
            }
        }
        str = argv[0];
        ptr = StringValuePtr(str);
        if (enc
            ? rb_reg_initialize(self, ptr, RSTRING_LEN(str), enc, flags, err, NULL, 0)
            : rb_reg_initialize_str(self, str, flags, err, NULL, 0)) {
            rb_reg_raise_str(str, flags, err);
        }
    }
    return self;
}</code>
</pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
        <div id="quote-method" class="method-detail ">
          <a name="method-c-quote"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">escape(str)   &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">quote(str)    &rarr; string</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string, or self if no characters are
escaped.  For any string, <tt><a
href="Regexp.html#method-c-new">Regexp.new</a>(<a
href="Regexp.html#method-c-escape">Regexp.escape</a>(<em>str</em>))=~<em>str</em></tt>
will be true.</p>

<pre>Regexp.escape('\*?{}.')   #=&gt; \\\*\?\{\}\.</pre>
            

            
            <div class="method-source-code" id="quote-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_s_quote(VALUE c, VALUE str)
{
    return rb_reg_quote(reg_operand(str, TRUE));
}</code>
</pre> 
            </div><!-- quote-source -->
            
          </div>

          

          
        </div><!-- quote-method -->

      
        <div id="try_convert-method" class="method-detail ">
          <a name="method-c-try_convert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">try_convert(obj) &rarr; re or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Try to convert <em>obj</em> into a <a href="Regexp.html">Regexp</a>, using
to_regexp method. Returns converted regexp or nil if <em>obj</em> cannot be
converted for any reason.</p>

<pre>Regexp.try_convert(/re/)         #=&gt; /re/
Regexp.try_convert(&quot;re&quot;)         #=&gt; nil

o = Object.new
Regexp.try_convert(o)            #=&gt; nil
def o.to_regexp() /foo/ end
Regexp.try_convert(o)            #=&gt; /foo/</pre>
            

            
            <div class="method-source-code" id="try_convert-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_s_try_convert(VALUE dummy, VALUE re)
{
    return rb_check_regexp_type(re);
}</code>
</pre> 
            </div><!-- try_convert-source -->
            
          </div>

          

          
        </div><!-- try_convert-method -->

      
        <div id="union-method" class="method-detail ">
          <a name="method-c-union"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">union(pat1, pat2, ...)            &rarr; new_regexp</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">union(pats_ary)                   &rarr; new_regexp</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Return a <tt><a href="Regexp.html">Regexp</a></tt> object that is the union
of the given <em>pattern</em>s, i.e., will match any of its parts. The
<em>pattern</em>s can be <a href="Regexp.html">Regexp</a> objects, in which
case their options will be preserved, or Strings. If no patterns are given,
returns <tt>/(?!)/</tt>. The behavior is unspecified if any given
<em>pattern</em> contains capture.</p>

<pre>Regexp.union                         #=&gt; /(?!)/
Regexp.union(&quot;penzance&quot;)             #=&gt; /penzance/
Regexp.union(&quot;a+b*c&quot;)                #=&gt; /a\+b\*c/
Regexp.union(&quot;skiing&quot;, &quot;sledding&quot;)   #=&gt; /skiing|sledding/
Regexp.union([&quot;skiing&quot;, &quot;sledding&quot;]) #=&gt; /skiing|sledding/
Regexp.union(/dogs/, /cats/i)        #=&gt; /(?-mix:dogs)|(?i-mx:cats)/</pre>
            

            
            <div class="method-source-code" id="union-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_s_union_m(VALUE self, VALUE args)
{
    VALUE v;
    if (RARRAY_LEN(args) == 1 &amp;&amp;
        !NIL_P(v = rb_check_array_type(rb_ary_entry(args, 0)))) {
        return rb_reg_s_union(self, v);
    }
    return rb_reg_s_union(self, args);
}</code>
</pre> 
            </div><!-- union-source -->
            
          </div>

          

          
        </div><!-- union-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rxp == other_rxp      &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">eql?(other_rxp)   &rarr; true or false</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Equality—Two regexps are equal if their patterns are identical, they have
the same character set code, and their <tt>casefold?</tt> values are the
same.</p>

<pre>/abc/  == /abc/x   #=&gt; false
/abc/  == /abc/i   #=&gt; false
/abc/  == /abc/n   #=&gt; false
/abc/u == /abc/n   #=&gt; false</pre>
            

            
            <div class="method-source-code" id="3D-3D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_equal(VALUE re1, VALUE re2)
{
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    rb_reg_check(re1); rb_reg_check(re2);
    if (FL_TEST(re1, KCODE_FIXED) != FL_TEST(re2, KCODE_FIXED)) return Qfalse;
    if (RREGEXP(re1)-&gt;ptr-&gt;options != RREGEXP(re2)-&gt;ptr-&gt;options) return Qfalse;
    if (RREGEXP_SRC_LEN(re1) != RREGEXP_SRC_LEN(re2)) return Qfalse;
    if (ENCODING_GET(re1) != ENCODING_GET(re2)) return Qfalse;
    if (memcmp(RREGEXP_SRC_PTR(re1), RREGEXP_SRC_PTR(re2), RREGEXP_SRC_LEN(re1)) == 0) {
        return Qtrue;
    }
    return Qfalse;
}</code>
</pre> 
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-method -->

      
        <div id="3D-3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rxp === str   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Case Equality—Synonym for <tt>Regexp#=~</tt> used in case statements.</p>

<pre>a = &quot;HELLO&quot;
case a
when /^[a-z]*$/; print &quot;Lower case\n&quot;
when /^[A-Z]*$/; print &quot;Upper case\n&quot;
else;            print &quot;Mixed case\n&quot;
end</pre>

<p><em>produces:</em></p>

<pre>Upper case</pre>
            

            
            <div class="method-source-code" id="3D-3D-3D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_reg_eqq(VALUE re, VALUE str)
{
    long start;

    str = reg_operand(str, FALSE);
    if (NIL_P(str)) {
        rb_backref_set(Qnil);
        return Qfalse;
    }
    start = rb_reg_search(re, str, 0, 0);
    if (start &lt; 0) {
        return Qfalse;
    }
    return Qtrue;
}</code>
</pre> 
            </div><!-- 3D-3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-3D-method -->

      
        <div id="3D-7E-method" class="method-detail ">
          <a name="method-i-3D-7E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rxp =~ str    &rarr; integer or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Match—Matches <em>rxp</em> against <em>str</em>.</p>

<pre>/at/ =~ &quot;input data&quot;   #=&gt; 7
/ax/ =~ &quot;input data&quot;   #=&gt; nil</pre>

<p>If <tt>=~</tt> is used with a regexp literal with named captures, captured
strings (or nil) is assigned to local variables named by the capture names.</p>

<pre>/(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;  x = y  &quot;
p lhs    #=&gt; &quot;x&quot;
p rhs    #=&gt; &quot;y&quot;</pre>

<p>If it is not matched, nil is assigned for the variables.</p>

<pre>/(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;  x = &quot;
p lhs    #=&gt; nil
p rhs    #=&gt; nil</pre>

<p>This assignment is implemented in the Ruby parser. The parser detects
‘regexp-literal =~ expression’ for the assignment. The regexp must be a
literal without interpolation and placed at left hand side.</p>

<p>The assignment is not occur if the regexp is not a literal.</p>

<pre>re = /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/
re =~ &quot;  x = y  &quot;
p lhs    # undefined local variable
p rhs    # undefined local variable</pre>

<p>A regexp interpolation, <tt>#{}</tt>, also disables the assignment.</p>

<pre>rhs_pat = /(?&lt;rhs&gt;\w+)/
/(?&lt;lhs&gt;\w+)\s*=\s*#{rhs_pat}/ =~ &quot;x = y&quot;
p lhs    # undefined local variable</pre>

<p>The assignment is not occur if the regexp is placed at right hand side.</p>

<pre>&quot;  x = y  &quot; =~ /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/
p lhs, rhs # undefined local variable</pre>
            

            
            <div class="method-source-code" id="3D-7E-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_reg_match(VALUE re, VALUE str)
{
    long pos = reg_match_pos(re, &amp;str, 0);
    if (pos &lt; 0) return Qnil;
    pos = rb_str_sublen(str, pos);
    return LONG2FIX(pos);
}</code>
</pre> 
            </div><!-- 3D-7E-source -->
            
          </div>

          

          
        </div><!-- 3D-7E-method -->

      
        <div id="casefold-3F-method" class="method-detail ">
          <a name="method-i-casefold-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">casefold?   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the value of the case-insensitive flag.</p>

<pre>/a/.casefold?           #=&gt; false
/a/i.casefold?          #=&gt; true
/(?i:a)/.casefold?      #=&gt; false</pre>
            

            
            <div class="method-source-code" id="casefold-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_casefold_p(VALUE re)
{
    rb_reg_check(re);
    if (RREGEXP(re)-&gt;ptr-&gt;options &amp; ONIG_OPTION_IGNORECASE) return Qtrue;
    return Qfalse;
}</code>
</pre> 
            </div><!-- casefold-3F-source -->
            
          </div>

          

          
        </div><!-- casefold-3F-method -->

      
        <div id="encoding-method" class="method-detail ">
          <a name="method-i-encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">encoding   &rarr; encoding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the <a href="Encoding.html">Encoding</a> object that represents the
encoding of obj.</p>
            

            
            <div class="method-source-code" id="encoding-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_obj_encoding(VALUE obj)
{
    rb_encoding *enc = rb_enc_get(obj);
    if (!enc) {
	rb_raise(rb_eTypeError, &quot;unknown encoding&quot;);
    }
    return rb_enc_from_encoding(enc);
}</code>
</pre> 
            </div><!-- encoding-source -->
            
          </div>

          

          
        </div><!-- encoding-method -->

      
        <div id="eql-3F-method" class="method-detail ">
          <a name="method-i-eql-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rxp == other_rxp      &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">eql?(other_rxp)   &rarr; true or false</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Equality—Two regexps are equal if their patterns are identical, they have
the same character set code, and their <tt>casefold?</tt> values are the
same.</p>

<pre>/abc/  == /abc/x   #=&gt; false
/abc/  == /abc/i   #=&gt; false
/abc/  == /abc/n   #=&gt; false
/abc/u == /abc/n   #=&gt; false</pre>
            

            
            <div class="method-source-code" id="eql-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_equal(VALUE re1, VALUE re2)
{
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    rb_reg_check(re1); rb_reg_check(re2);
    if (FL_TEST(re1, KCODE_FIXED) != FL_TEST(re2, KCODE_FIXED)) return Qfalse;
    if (RREGEXP(re1)-&gt;ptr-&gt;options != RREGEXP(re2)-&gt;ptr-&gt;options) return Qfalse;
    if (RREGEXP_SRC_LEN(re1) != RREGEXP_SRC_LEN(re2)) return Qfalse;
    if (ENCODING_GET(re1) != ENCODING_GET(re2)) return Qfalse;
    if (memcmp(RREGEXP_SRC_PTR(re1), RREGEXP_SRC_PTR(re2), RREGEXP_SRC_LEN(re1)) == 0) {
        return Qtrue;
    }
    return Qfalse;
}</code>
</pre> 
            </div><!-- eql-3F-source -->
            
          </div>

          

          
        </div><!-- eql-3F-method -->

      
        <div id="fixed_encoding-3F-method" class="method-detail ">
          <a name="method-i-fixed_encoding-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fixed_encoding?   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns false if rxp is applicable to a string with any ASCII compatible
encoding. Returns true otherwise.</p>

<pre>r = /a/
r.fixed_encoding?                               #=&gt; false
r =~ &quot;\u{6666} a&quot;                               #=&gt; 2
r =~ &quot;\xa1\xa2 a&quot;.force_encoding(&quot;euc-jp&quot;)      #=&gt; 2
r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             #=&gt; 0

r = /a/u
r.fixed_encoding?                               #=&gt; true
r.encoding                                      #=&gt; #&lt;Encoding:UTF-8&gt;
r =~ &quot;\u{6666} a&quot;                               #=&gt; 2
r =~ &quot;\xa1\xa2&quot;.force_encoding(&quot;euc-jp&quot;)        #=&gt; ArgumentError
r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             #=&gt; 0

r = /\u{6666}/
r.fixed_encoding?                               #=&gt; true
r.encoding                                      #=&gt; #&lt;Encoding:UTF-8&gt;
r =~ &quot;\u{6666} a&quot;                               #=&gt; 0
r =~ &quot;\xa1\xa2&quot;.force_encoding(&quot;euc-jp&quot;)        #=&gt; ArgumentError
r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             #=&gt; nil</pre>
            

            
            <div class="method-source-code" id="fixed_encoding-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_fixed_encoding_p(VALUE re)
{
    if (FL_TEST(re, KCODE_FIXED))
        return Qtrue;
    else
        return Qfalse;
}</code>
</pre> 
            </div><!-- fixed_encoding-3F-source -->
            
          </div>

          

          
        </div><!-- fixed_encoding-3F-method -->

      
        <div id="hash-method" class="method-detail ">
          <a name="method-i-hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash   &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Produce a hash based on the text and options of this regular expression.</p>
            

            
            <div class="method-source-code" id="hash-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_hash(VALUE re)
{
    st_index_t hashval = reg_hash(re);
    return LONG2FIX(hashval);
}</code>
</pre> 
            </div><!-- hash-source -->
            
          </div>

          

          
        </div><!-- hash-method -->

      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inspect   &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Produce a nicely formatted string-version of <em>rxp</em>. Perhaps
surprisingly, <tt><a href="Regexp.html#method-i-inspect">inspect</a></tt>
actually produces the more natural version of the string than <tt><a
href="Regexp.html#method-i-to_s">to_s</a></tt>.</p>

<pre>/ab+c/ix.inspect        #=&gt; &quot;/ab+c/ix&quot;</pre>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_inspect(VALUE re)
{
    if (!RREGEXP(re)-&gt;ptr || !RREGEXP_SRC(re) || !RREGEXP_SRC_PTR(re)) {
        return rb_any_to_s(re);
    }
    return rb_reg_desc(RREGEXP_SRC_PTR(re), RREGEXP_SRC_LEN(re), re);
}</code>
</pre> 
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->

      
        <div id="match-method" class="method-detail ">
          <a name="method-i-match"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">match(str)       &rarr; matchdata or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">match(str,pos)   &rarr; matchdata or nil</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a <tt><a href="MatchData.html">MatchData</a></tt> object describing
the match, or <tt>nil</tt> if there was no match. This is equivalent to
retrieving the value of the special variable <tt>$~</tt> following a normal
match. If the second parameter is present, it specifies the position in the
string to begin the search.</p>

<pre>/(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;
/(.)(.)/.match(&quot;abc&quot;, 1)[2]   #=&gt; &quot;c&quot;</pre>

<p>If a block is given, invoke the block with <a
href="MatchData.html">MatchData</a> if match succeed, so that you can write</p>

<pre>pat.match(str) {|m| ...}</pre>

<p>instead of</p>

<pre>if m = pat.match(str)
  ...
end</pre>

<p>The return value is a value from block execution in this case.</p>
            

            
            <div class="method-source-code" id="match-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_match_m(int argc, VALUE *argv, VALUE re)
{
    VALUE result, str, initpos;
    long pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;str, &amp;initpos) == 2) {
        pos = NUM2LONG(initpos);
    }
    else {
        pos = 0;
    }

    pos = reg_match_pos(re, &amp;str, pos);
    if (pos &lt; 0) {
        rb_backref_set(Qnil);
        return Qnil;
    }
    result = rb_backref_get();
    rb_match_busy(result);
    if (!NIL_P(result) &amp;&amp; rb_block_given_p()) {
        return rb_yield(result);
    }
    return result;
}</code>
</pre> 
            </div><!-- match-source -->
            
          </div>

          

          
        </div><!-- match-method -->

      
        <div id="named_captures-method" class="method-detail ">
          <a name="method-i-named_captures"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">named_captures  &rarr; hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a hash representing information about named captures of
<em>rxp</em>.</p>

<p>A key of the hash is a name of the named captures. A value of the hash is
an array which is list of indexes of corresponding named captures.</p>

<pre>/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/.named_captures
#=&gt; {&quot;foo&quot;=&gt;[1], &quot;bar&quot;=&gt;[2]}

/(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.named_captures
#=&gt; {&quot;foo&quot;=&gt;[1, 2]}</pre>

<p>If there are no named captures, an empty hash is returned.</p>

<pre>/(.)(.)/.named_captures
#=&gt; {}</pre>
            

            
            <div class="method-source-code" id="named_captures-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_named_captures(VALUE re)
{
    VALUE hash = rb_hash_new();
    rb_reg_check(re);
    onig_foreach_name(RREGEXP(re)-&gt;ptr, reg_named_captures_iter, (void*)hash);
    return hash;
}</code>
</pre> 
            </div><!-- named_captures-source -->
            
          </div>

          

          
        </div><!-- named_captures-method -->

      
        <div id="names-method" class="method-detail ">
          <a name="method-i-names"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">names   &rarr; [name1, name2, ...]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a list of names of captures as an array of strings.</p>

<pre>/(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.names
#=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]

/(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.names
#=&gt; [&quot;foo&quot;]

/(.)(.)/.names
#=&gt; []</pre>
            

            
            <div class="method-source-code" id="names-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_names(VALUE re)
{
    VALUE ary = rb_ary_new();
    rb_reg_check(re);
    onig_foreach_name(RREGEXP(re)-&gt;ptr, reg_names_iter, (void*)ary);
    return ary;
}</code>
</pre> 
            </div><!-- names-source -->
            
          </div>

          

          
        </div><!-- names-method -->

      
        <div id="options-method" class="method-detail ">
          <a name="method-i-options"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">options   &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the set of bits corresponding to the options used when creating
this <a href="Regexp.html">Regexp</a> (see <tt><a
href="Regexp.html#method-c-new">Regexp::new</a></tt> for details. Note that
additional bits may be set in the returned options: these are used
internally by the regular expression code. These extra bits are ignored if
the options are passed to <tt><a
href="Regexp.html#method-c-new">Regexp::new</a></tt>.</p>

<pre>Regexp::IGNORECASE                  #=&gt; 1
Regexp::EXTENDED                    #=&gt; 2
Regexp::MULTILINE                   #=&gt; 4

/cat/.options                       #=&gt; 0
/cat/ix.options                     #=&gt; 3
Regexp.new('cat', true).options     #=&gt; 1
/\xa1\xa2/e.options                 #=&gt; 16

r = /cat/ix
Regexp.new(r.source, r.options)     #=&gt; /cat/ix</pre>
            

            
            <div class="method-source-code" id="options-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_options_m(VALUE re)
{
    int options = rb_reg_options(re);
    return INT2NUM(options);
}</code>
</pre> 
            </div><!-- options-source -->
            
          </div>

          

          
        </div><!-- options-method -->

      
        <div id="source-method" class="method-detail ">
          <a name="method-i-source"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">source   &rarr; str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the original string of the pattern.</p>

<pre>/ab+c/ix.source #=&gt; &quot;ab+c&quot;</pre>

<p>Note that escape sequences are retained as is.</p>

<pre>/\x20\+/.source  #=&gt; &quot;\\x20\\+&quot;</pre>
            

            
            <div class="method-source-code" id="source-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_source(VALUE re)
{
    VALUE str;

    rb_reg_check(re);
    str = rb_enc_str_new(RREGEXP_SRC_PTR(re),RREGEXP_SRC_LEN(re), rb_enc_get(re));
    if (OBJ_TAINTED(re)) OBJ_TAINT(str);
    return str;
}</code>
</pre> 
            </div><!-- source-source -->
            
          </div>

          

          
        </div><!-- source-method -->

      
        <div id="to_s-method" class="method-detail ">
          <a name="method-i-to_s"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_s   &rarr; str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a string containing the regular expression and its options (using
the <tt>(?opts:source)</tt> notation. This string can be fed back in to
<tt><a href="Regexp.html#method-c-new">Regexp::new</a></tt> to a regular
expression with the same semantics as the original. (However,
<tt>Regexp#==</tt> may not return true when comparing the two, as the
source of the regular expression itself may differ, as the example shows). 
<tt><a href="Regexp.html#method-i-inspect">Regexp#inspect</a></tt> produces
a generally more readable version of <em>rxp</em>.</p>

<pre>r1 = /ab+c/ix           #=&gt; /ab+c/ix
s1 = r1.to_s            #=&gt; &quot;(?ix-m:ab+c)&quot;
r2 = Regexp.new(s1)     #=&gt; /(?ix-m:ab+c)/
r1 == r2                #=&gt; false
r1.source               #=&gt; &quot;ab+c&quot;
r2.source               #=&gt; &quot;(?ix-m:ab+c)&quot;</pre>
            

            
            <div class="method-source-code" id="to_s-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_reg_to_s(VALUE re)
{
    int options, opt;
    const int embeddable = ONIG_OPTION_MULTILINE|ONIG_OPTION_IGNORECASE|ONIG_OPTION_EXTEND;
    long len;
    const UChar* ptr;
    VALUE str = rb_str_buf_new2(&quot;(?&quot;);
    char optbuf[5];
    rb_encoding *enc = rb_enc_get(re);

    rb_reg_check(re);

    rb_enc_copy(str, re);
    options = RREGEXP(re)-&gt;ptr-&gt;options;
    ptr = (UChar*)RREGEXP_SRC_PTR(re);
    len = RREGEXP_SRC_LEN(re);
  again:
    if (len &gt;= 4 &amp;&amp; ptr[0] == '(' &amp;&amp; ptr[1] == '?') {
        int err = 1;
        ptr += 2;
        if ((len -= 2) &gt; 0) {
            do {
                opt = char_to_option((int )*ptr);
                if (opt != 0) {
                    options |= opt;
                }
                else {
                    break;
                }
                ++ptr;
            } while (--len &gt; 0);
        }
        if (len &gt; 1 &amp;&amp; *ptr == '-') {
            ++ptr;
            --len;
            do {
                opt = char_to_option((int )*ptr);
                if (opt != 0) {
                    options &amp;= ~opt;
                }
                else {
                    break;
                }
                ++ptr;
            } while (--len &gt; 0);
        }
        if (*ptr == ')') {
            --len;
            ++ptr;
            goto again;
        }
        if (*ptr == ':' &amp;&amp; ptr[len-1] == ')') {
            Regexp *rp;

            ++ptr;
            len -= 2;
            err = onig_new(&amp;rp, ptr, ptr + len, ONIG_OPTION_DEFAULT,
                           enc, OnigDefaultSyntax, NULL);
            onig_free(rp);
        }
        if (err) {
            options = RREGEXP(re)-&gt;ptr-&gt;options;
            ptr = (UChar*)RREGEXP_SRC_PTR(re);
            len = RREGEXP_SRC_LEN(re);
        }
    }

    if (*option_to_str(optbuf, options)) rb_str_buf_cat2(str, optbuf);

    if ((options &amp; embeddable) != embeddable) {
        optbuf[0] = '-';
        option_to_str(optbuf + 1, ~options);
        rb_str_buf_cat2(str, optbuf);
    }

    rb_str_buf_cat2(str, &quot;:&quot;);
    rb_reg_expr_str(str, (char*)ptr, len, enc, NULL);
    rb_str_buf_cat2(str, &quot;)&quot;);
    rb_enc_copy(str, re);

    OBJ_INFECT(str, re);
    return str;
}</code>
</pre> 
            </div><!-- to_s-source -->
            
          </div>

          

          
        </div><!-- to_s-method -->

      
        <div id="7E-method" class="method-detail ">
          <a name="method-i-7E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">~ rxp   &rarr; integer or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Match—Matches <em>rxp</em> against the contents of <tt>$_</tt>. Equivalent
to <tt><em>rxp</em> =~ $_</tt>.</p>

<pre>$_ = &quot;input data&quot;
~ /at/   #=&gt; 7</pre>
            

            
            <div class="method-source-code" id="7E-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_reg_match2(VALUE re)
{
    long start;
    VALUE line = rb_lastline_get();

    if (TYPE(line) != T_STRING) {
        rb_backref_set(Qnil);
        return Qnil;
    }

    start = rb_reg_search(re, line, 0, 0);
    if (start &lt; 0) {
        return Qnil;
    }
    start = rb_str_sublen(line, start);
    return LONG2FIX(start);
}</code>
</pre> 
            </div><!-- 7E-source -->
            
          </div>

          

          
        </div><!-- 7E-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  

  </div><!-- documentation -->
<div id="disqus_thread" style='display:none'></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    // var disqus_shortname = 'rubydocbeta'; // required 
    var disqus_shortname = 'ruby-doc'; // required 
    
    var disqus_developer = true; // DEBUGGERY
    


    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink" style='display:none'>blog comments powered by <span class="logo-disqus">Disqus</span></a>

<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 1.9.2</small></p> 
  
   <p> <a href="http://www.ruby-doc.org">Ruby-doc.org</a> is provided by <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>. <a href="http://www.neurogami.com">Hack your world.  Feed your head.  Live curious</a>.  </p>
 
    <p><small>Generated with the <a href="http://neurogami.com/code/">Rubydoc Rdoc Generator</a> 0.9.4</small>.</p>
  </div>

</div>

<script type="text/javascript">
var _uacct = "UA-335317-2";
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{ 
var pageTracker = _gat._getTracker(_uacct);
pageTracker._trackPageview();
} catch(err) {} 
</script>
</body>
</html>

