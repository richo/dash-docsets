<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <!-- RD version: 0.9.4  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <title>Class: Struct (Ruby 1.9.2) </title>
  <!-- raw_prefix  = '.'   -->
  <link rel="stylesheet" href="css/obf.css" >

  <script src="js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 
</head>

<body id="top" class="class">
<div id="actionbar" style='display:none' >
<div class='wrapper'>
<ul class='grids g0'>
  <li class='grid-2' ><a href='/' target='_top' >Home</a></li>
  <li class='grid-2' ><a href='/core' target='_top' >Core</a></li>
  <li class='grid-2' ><a href='/stdlib' target='_top' >Std-lib</a></li>
  <li class='grid-2' ><a href='/downloads' target='_top' >Downloads</a></li>
  <li class='grid-7 right' id='rd-action-search'><form id="searchbox_011815814100681837392:wnccv6st5qk" action="/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk" ><input name="q" type="text" size="20" >&#160;&#160;<input type="submit" name="sa" value="Search" ><input type="hidden" name="cof" value="FORID:9" ></form>
</li>
</ul>
</div>
</div> <!-- end action bar -->
          <div class='wrapper'>
  <div id="metadata" style='display:none'>
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="index.html">Home</a>
          <a href="index.html#classes">Classes</a>
          <a href="index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="struct_c.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="struct.c">struct.c</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-5B-5D-3D">#[]=</a></li>
          
          <li><a href="#method-i-each">#each</a></li>
          
          <li><a href="#method-i-each_pair">#each_pair</a></li>
          
          <li><a href="#method-i-eql-3F">#eql?</a></li>
          
          <li><a href="#method-i-hash">#hash</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-length">#length</a></li>
          
          <li><a href="#method-i-members">#members</a></li>
          
          <li><a href="#method-i-select">#select</a></li>
          
          <li><a href="#method-i-size">#size</a></li>
          
          <li><a href="#method-i-to_a">#to_a</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-values">#values</a></li>
          
          <li><a href="#method-i-values_at">#values_at</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><a class="include" href="Enumerable.html">Enumerable</a></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="Encoding.html">Encoding</a></li>
        
          <li><a href="Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          <li><a href="Encoding/Converter.html">Encoding::Converter</a></li>
        
          <li><a href="Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          <li><a href="Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          <li><a href="Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          <li><a href="Process.html">Process</a></li>
        
          <li><a href="Process/GID.html">Process::GID</a></li>
        
          <li><a href="Process/Status.html">Process::Status</a></li>
        
          <li><a href="Process/Sys.html">Process::Sys</a></li>
        
          <li><a href="Process/UID.html">Process::UID</a></li>
        
          <li><a href="Enumerator.html">Enumerator</a></li>
        
          <li><a href="Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          <li><a href="Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          <li><a href="File.html">File</a></li>
        
          <li><a href="File/Constants.html">File::Constants</a></li>
        
          <li><a href="File/Stat.html">File::Stat</a></li>
        
          <li><a href="IO.html">IO</a></li>
        
          <li><a href="IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          <li><a href="IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          <li><a href="RubyVM.html">RubyVM</a></li>
        
          <li><a href="RubyVM/Env.html">RubyVM::Env</a></li>
        
          <li><a href="RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          <li><a href="GC.html">GC</a></li>
        
          <li><a href="GC/Profiler.html">GC::Profiler</a></li>
        
          <li><a href="Math.html">Math</a></li>
        
          <li><a href="Math/DomainError.html">Math::DomainError</a></li>
        
          <li><a href="NameError.html">NameError</a></li>
        
          <li><a href="NameError/message.html">NameError::message</a></li>
        
          <li><a href="ARGF.html">ARGF</a></li>
        
          <li><a href="ArgumentError.html">ArgumentError</a></li>
        
          <li><a href="Array.html">Array</a></li>
        
          <li><a href="BasicObject.html">BasicObject</a></li>
        
          <li><a href="Bignum.html">Bignum</a></li>
        
          <li><a href="Binding.html">Binding</a></li>
        
          <li><a href="Class.html">Class</a></li>
        
          <li><a href="Comparable.html">Comparable</a></li>
        
          <li><a href="Complex.html">Complex</a></li>
        
          <li><a href="Continuation.html">Continuation</a></li>
        
          <li><a href="Data.html">Data</a></li>
        
          <li><a href="Dir.html">Dir</a></li>
        
          <li><a href="EOFError.html">EOFError</a></li>
        
          <li><a href="EncodingError.html">EncodingError</a></li>
        
          <li><a href="Enumerable.html">Enumerable</a></li>
        
          <li><a href="Errno.html">Errno</a></li>
        
          <li><a href="Exception.html">Exception</a></li>
        
          <li><a href="FalseClass.html">FalseClass</a></li>
        
          <li><a href="Fiber.html">Fiber</a></li>
        
          <li><a href="FiberError.html">FiberError</a></li>
        
          <li><a href="FileTest.html">FileTest</a></li>
        
          <li><a href="Fixnum.html">Fixnum</a></li>
        
          <li><a href="Float.html">Float</a></li>
        
          <li><a href="FloatDomainError.html">FloatDomainError</a></li>
        
          <li><a href="Hash.html">Hash</a></li>
        
          <li><a href="IOError.html">IOError</a></li>
        
          <li><a href="IndexError.html">IndexError</a></li>
        
          <li><a href="Integer.html">Integer</a></li>
        
          <li><a href="Interrupt.html">Interrupt</a></li>
        
          <li><a href="Kernel.html">Kernel</a></li>
        
          <li><a href="KeyError.html">KeyError</a></li>
        
          <li><a href="LoadError.html">LoadError</a></li>
        
          <li><a href="LocalJumpError.html">LocalJumpError</a></li>
        
          <li><a href="Marshal.html">Marshal</a></li>
        
          <li><a href="MatchData.html">MatchData</a></li>
        
          <li><a href="Method.html">Method</a></li>
        
          <li><a href="Module.html">Module</a></li>
        
          <li><a href="Mutex.html">Mutex</a></li>
        
          <li><a href="NilClass.html">NilClass</a></li>
        
          <li><a href="NoMemoryError.html">NoMemoryError</a></li>
        
          <li><a href="NoMethodError.html">NoMethodError</a></li>
        
          <li><a href="NotImplementedError.html">NotImplementedError</a></li>
        
          <li><a href="Numeric.html">Numeric</a></li>
        
          <li><a href="Object.html">Object</a></li>
        
          <li><a href="ObjectSpace.html">ObjectSpace</a></li>
        
          <li><a href="Proc.html">Proc</a></li>
        
          <li><a href="Random.html">Random</a></li>
        
          <li><a href="Range.html">Range</a></li>
        
          <li><a href="RangeError.html">RangeError</a></li>
        
          <li><a href="Rational.html">Rational</a></li>
        
          <li><a href="Regexp.html">Regexp</a></li>
        
          <li><a href="RegexpError.html">RegexpError</a></li>
        
          <li><a href="RuntimeError.html">RuntimeError</a></li>
        
          <li><a href="ScriptError.html">ScriptError</a></li>
        
          <li><a href="SecurityError.html">SecurityError</a></li>
        
          <li><a href="Signal.html">Signal</a></li>
        
          <li><a href="SignalException.html">SignalException</a></li>
        
          <li><a href="StandardError.html">StandardError</a></li>
        
          <li><a href="StopIteration.html">StopIteration</a></li>
        
          <li><a href="String.html">String</a></li>
        
          <li><a href="Struct.html">Struct</a></li>
        
          <li><a href="Symbol.html">Symbol</a></li>
        
          <li><a href="SyntaxError.html">SyntaxError</a></li>
        
          <li><a href="SystemCallError.html">SystemCallError</a></li>
        
          <li><a href="SystemExit.html">SystemExit</a></li>
        
          <li><a href="SystemStackError.html">SystemStackError</a></li>
        
          <li><a href="Thread.html">Thread</a></li>
        
          <li><a href="ThreadError.html">ThreadError</a></li>
        
          <li><a href="ThreadGroup.html">ThreadGroup</a></li>
        
          <li><a href="Time.html">Time</a></li>
        
          <li><a href="TrueClass.html">TrueClass</a></li>
        
          <li><a href="TypeError.html">TypeError</a></li>
        
          <li><a href="UnboundMethod.html">UnboundMethod</a></li>
        
          <li><a href="ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          <li><a href="fatal.html">fatal</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation" style='margin: 10px 10px 10px 10px'>
    <h1 class="class">Struct</h1>

    <div id="description" class="description">
      
<p>A <tt><a href="Struct.html">Struct</a></tt> is a convenient way to bundle a
number of attributes together, using accessor methods, without having to
write an explicit class.</p>

<p>The <tt><a href="Struct.html">Struct</a></tt> class is a generator of
specific classes, each one of which is defined to hold a set of variables
and their accessors. In these examples, we’ll call the generated class
“<em>Customer</em><a href="Class.html">Class</a>,” and we’ll show an
example instance of that class as “<em>Customer</em>Inst.”</p>

<p>In the descriptions that follow, the parameter <em>symbol</em> refers to a
symbol, which is either a quoted string or a <tt><a
href="Symbol.html">Symbol</a></tt> (such as <tt>:name</tt>).</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new( [aString] [, aSym]+> )    &rarr; StructClass</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new(arg, ...)             &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">StructClass[arg, ...]                 &rarr; obj</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Creates a new class, named by <em>a<a href="String.html">String</a></em>,
containing accessor methods for the given symbols. If the name <em>a<a
href="String.html">String</a></em> is omitted, an anonymous structure class
will be created. Otherwise, the name of this struct will appear as a
constant in class <tt><a href="Struct.html">Struct</a></tt>, so it must be
unique for all <tt><a href="Struct.html">Struct</a></tt>s in the system and
should start with a capital letter. Assigning a structure class to a
constant effectively gives the class the name of the constant.</p>

<p><tt><a href="Struct.html#method-c-new">Struct::new</a></tt> returns a new
<tt><a href="Class.html">Class</a></tt> object, which can then be used to
create specific instances of the new structure. The number of actual
parameters must be less than or equal to the number of attributes defined
for this class; unset parameters default to <tt>nil</tt>.  Passing too many
parameters will raise an <tt><a
href="ArgumentError.html">ArgumentError</a></tt>.</p>

<p>The remaining methods listed in this section (class and instance) are
defined for this generated class.</p>

<pre># Create a structure with a name in Struct
Struct.new(&quot;Customer&quot;, :name, :address)    #=&gt; Struct::Customer
Struct::Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)   #=&gt; #&lt;struct Struct::Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;

# Create a structure named by its constant
Customer = Struct.new(:name, :address)     #=&gt; Customer
Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)           #=&gt; #&lt;struct Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_s_def(int argc, VALUE *argv, VALUE klass)
{
    VALUE name, rest;
    long i;
    VALUE st;
    ID id;

    rb_scan_args(argc, argv, &quot;1*&quot;, &amp;name, &amp;rest);
    if (!NIL_P(name) &amp;&amp; SYMBOL_P(name)) {
        rb_ary_unshift(rest, name);
        name = Qnil;
    }
    for (i=0; i&lt;RARRAY_LEN(rest); i++) {
        id = rb_to_id(RARRAY_PTR(rest)[i]);
        RARRAY_PTR(rest)[i] = ID2SYM(id);
    }
    st = make_struct(name, rest, klass);
    if (rb_block_given_p()) {
        rb_mod_module_eval(0, 0, st);
    }

    return st;
}</code>
</pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">struct == other_struct     &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Equality—Returns <tt>true</tt> if <em>other_struct</em> is equal to this
one: they must be of the same class as generated by <tt><a
href="Struct.html#method-c-new">Struct::new</a></tt>, and the values of all
instance variables must be equal (according to <tt>Object#==</tt>).</p>

<pre>Customer = Struct.new(:name, :address, :zip)
joe   = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
joejr = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
jane  = Customer.new(&quot;Jane Doe&quot;, &quot;456 Elm, Anytown NC&quot;, 12345)
joe == joejr   #=&gt; true
joe == jane    #=&gt; false</pre>
            

            
            <div class="method-source-code" id="3D-3D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_equal(VALUE s, VALUE s2)
{
    if (s == s2) return Qtrue;
    if (TYPE(s2) != T_STRUCT) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT_LEN(s) != RSTRUCT_LEN(s2)) {
        rb_bug(&quot;inconsistent struct&quot;); /* should never happen */
    }

    return rb_exec_recursive_paired(recursive_equal, s, s2, s2);
}</code>
</pre> 
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-method -->

      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">struct[symbol]    &rarr; anObject</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">struct[fixnum]    &rarr; anObject</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Attribute Reference—Returns the value of the instance variable named by
<em>symbol</em>, or indexed (0..length-1) by <em>fixnum</em>. Will raise
<tt><a href="NameError.html">NameError</a></tt> if the named variable does
not exist, or <tt><a href="IndexError.html">IndexError</a></tt> if the
index is out of range.</p>

<pre>Customer = Struct.new(:name, :address, :zip)
joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)

joe[&quot;name&quot;]   #=&gt; &quot;Joe Smith&quot;
joe[:name]    #=&gt; &quot;Joe Smith&quot;
joe[0]        #=&gt; &quot;Joe Smith&quot;</pre>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_struct_aref(VALUE s, VALUE idx)
{
    long i;

    if (TYPE(idx) == T_STRING || TYPE(idx) == T_SYMBOL) {
        return rb_struct_aref_id(s, rb_to_id(idx));
    }

    i = NUM2LONG(idx);
    if (i &lt; 0) i = RSTRUCT_LEN(s) + i;
    if (i &lt; 0)
        rb_raise(rb_eIndexError, &quot;offset %ld too small for struct(size:%ld)&quot;,
                 i, RSTRUCT_LEN(s));
    if (RSTRUCT_LEN(s) &lt;= i)
        rb_raise(rb_eIndexError, &quot;offset %ld too large for struct(size:%ld)&quot;,
                 i, RSTRUCT_LEN(s));
    return RSTRUCT_PTR(s)[i];
}</code>
</pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->

      
        <div id="5B-5D-3D-method" class="method-detail ">
          <a name="method-i-5B-5D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">struct[symbol] = obj    &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">struct[fixnum] = obj    &rarr; obj</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Attribute Assignment—Assigns to the instance variable named by
<em>symbol</em> or <em>fixnum</em> the value <em>obj</em> and returns it.
Will raise a <tt><a href="NameError.html">NameError</a></tt> if the named
variable does not exist, or an <tt><a
href="IndexError.html">IndexError</a></tt> if the index is out of range.</p>

<pre>Customer = Struct.new(:name, :address, :zip)
joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)

joe[&quot;name&quot;] = &quot;Luke&quot;
joe[:zip]   = &quot;90210&quot;

joe.name   #=&gt; &quot;Luke&quot;
joe.zip    #=&gt; &quot;90210&quot;</pre>
            

            
            <div class="method-source-code" id="5B-5D-3D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_struct_aset(VALUE s, VALUE idx, VALUE val)
{
    long i;

    if (TYPE(idx) == T_STRING || TYPE(idx) == T_SYMBOL) {
        return rb_struct_aset_id(s, rb_to_id(idx), val);
    }

    i = NUM2LONG(idx);
    if (i &lt; 0) i = RSTRUCT_LEN(s) + i;
    if (i &lt; 0) {
        rb_raise(rb_eIndexError, &quot;offset %ld too small for struct(size:%ld)&quot;,
                 i, RSTRUCT_LEN(s));
    }
    if (RSTRUCT_LEN(s) &lt;= i) {
        rb_raise(rb_eIndexError, &quot;offset %ld too large for struct(size:%ld)&quot;,
                 i, RSTRUCT_LEN(s));
    }
    rb_struct_modify(s);
    return RSTRUCT_PTR(s)[i] = val;
}</code>
</pre> 
            </div><!-- 5B-5D-3D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-3D-method -->

      
        <div id="each-method" class="method-detail ">
          <a name="method-i-each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each {|obj| block }  &rarr; struct</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each                 &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Calls <em>block</em> once for each instance variable, passing the value as
a parameter.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>Customer = Struct.new(:name, :address, :zip)
joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
joe.each {|x| puts(x) }</pre>

<p><em>produces:</em></p>

<pre>Joe Smith
123 Maple, Anytown NC
12345</pre>
            

            
            <div class="method-source-code" id="each-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_each(VALUE s)
{
    long i;

    RETURN_ENUMERATOR(s, 0, 0);
    for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
        rb_yield(RSTRUCT_PTR(s)[i]);
    }
    return s;
}</code>
</pre> 
            </div><!-- each-source -->
            
          </div>

          

          
        </div><!-- each-method -->

      
        <div id="each_pair-method" class="method-detail ">
          <a name="method-i-each_pair"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_pair {|sym, obj| block }     &rarr; struct</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_pair                         &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Calls <em>block</em> once for each instance variable, passing the name (as
a symbol) and the value as parameters.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>Customer = Struct.new(:name, :address, :zip)
joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
joe.each_pair {|name, value| puts(&quot;#{name} =&gt; #{value}&quot;) }</pre>

<p><em>produces:</em></p>

<pre>name =&gt; Joe Smith
address =&gt; 123 Maple, Anytown NC
zip =&gt; 12345</pre>
            

            
            <div class="method-source-code" id="each_pair-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_each_pair(VALUE s)
{
    VALUE members;
    long i;

    RETURN_ENUMERATOR(s, 0, 0);
    members = rb_struct_members(s);
    for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
        rb_yield_values(2, rb_ary_entry(members, i), RSTRUCT_PTR(s)[i]);
    }
    return s;
}</code>
</pre> 
            </div><!-- each_pair-source -->
            
          </div>

          

          
        </div><!-- each_pair-method -->

      
        <div id="eql-3F-method" class="method-detail ">
          <a name="method-i-eql-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">eql?</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>code-seq:</p>

<pre>struct.eql?(other)   -&gt; true or false</pre>

<p>Two structures are equal if they are the same object, or if all their
fields are equal (using <tt>eql?</tt>).</p>
            

            
            <div class="method-source-code" id="eql-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_eql(VALUE s, VALUE s2)
{
    if (s == s2) return Qtrue;
    if (TYPE(s2) != T_STRUCT) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT_LEN(s) != RSTRUCT_LEN(s2)) {
        rb_bug(&quot;inconsistent struct&quot;); /* should never happen */
    }

    return rb_exec_recursive_paired(recursive_eql, s, s2, s2);
}</code>
</pre> 
            </div><!-- eql-3F-source -->
            
          </div>

          

          
        </div><!-- eql-3F-method -->

      
        <div id="hash-method" class="method-detail ">
          <a name="method-i-hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash   &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Return a hash value based on this struct’s contents.</p>
            

            
            <div class="method-source-code" id="hash-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_hash(VALUE s)
{
    return rb_exec_recursive_outer(recursive_hash, s, 0);
}</code>
</pre> 
            </div><!-- hash-source -->
            
          </div>

          

          
        </div><!-- hash-method -->

      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_s      &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inspect   &rarr; string</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Describe the contents of this struct in a string.</p>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_inspect(VALUE s)
{
    return rb_exec_recursive(inspect_struct, s, 0);
}</code>
</pre> 
            </div><!-- inspect-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Struct.html#method-i-to_s">to_s</a>
          </div>
          

          
        </div><!-- inspect-method -->

      
        <div id="length-method" class="method-detail ">
          <a name="method-i-length"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">length    &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">size      &rarr; fixnum</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the number of instance variables.</p>

<pre>Customer = Struct.new(:name, :address, :zip)
joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
joe.length   #=&gt; 3</pre>
            

            
            <div class="method-source-code" id="length-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_size(VALUE s)
{
    return LONG2FIX(RSTRUCT_LEN(s));
}</code>
</pre> 
            </div><!-- length-source -->
            
          </div>

          

          
        </div><!-- length-method -->

      
        <div id="members-method" class="method-detail ">
          <a name="method-i-members"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">members    &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array of strings representing the names of the instance
variables.</p>

<pre>Customer = Struct.new(:name, :address, :zip)
joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
joe.members   #=&gt; [:name, :address, :zip]</pre>
            

            
            <div class="method-source-code" id="members-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_members_m(VALUE obj)
{
    return rb_struct_s_members_m(rb_obj_class(obj));
}</code>
</pre> 
            </div><!-- members-source -->
            
          </div>

          

          
        </div><!-- members-method -->

      
        <div id="select-method" class="method-detail ">
          <a name="method-i-select"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select {|i| block }    &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select                 &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Invokes the block passing in successive elements from <em>struct</em>,
returning an array containing those elements for which the block returns a
true value (equivalent to <tt><a
href="Enumerable.html#method-i-select">Enumerable#select</a></tt>).</p>

<pre>Lots = Struct.new(:a, :b, :c, :d, :e, :f)
l = Lots.new(11, 22, 33, 44, 55, 66)
l.select {|v| (v % 2).zero? }   #=&gt; [22, 44, 66]</pre>
            

            
            <div class="method-source-code" id="select-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_select(int argc, VALUE *argv, VALUE s)
{
    VALUE result;
    long i;

    if (argc &gt; 0) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 0)&quot;, argc);
    }
    RETURN_ENUMERATOR(s, 0, 0);
    result = rb_ary_new();
    for (i = 0; i &lt; RSTRUCT_LEN(s); i++) {
        if (RTEST(rb_yield(RSTRUCT_PTR(s)[i]))) {
            rb_ary_push(result, RSTRUCT_PTR(s)[i]);
        }
    }

    return result;
}</code>
</pre> 
            </div><!-- select-source -->
            
          </div>

          

          
        </div><!-- select-method -->

      
        <div id="size-method" class="method-detail ">
          <a name="method-i-size"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">length    &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">size      &rarr; fixnum</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the number of instance variables.</p>

<pre>Customer = Struct.new(:name, :address, :zip)
joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
joe.length   #=&gt; 3</pre>
            

            
            <div class="method-source-code" id="size-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_size(VALUE s)
{
    return LONG2FIX(RSTRUCT_LEN(s));
}</code>
</pre> 
            </div><!-- size-source -->
            
          </div>

          

          
        </div><!-- size-method -->

      
        <div id="to_a-method" class="method-detail ">
          <a name="method-i-to_a"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a     &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">values   &rarr; array</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the values for this instance as an array.</p>

<pre>Customer = Struct.new(:name, :address, :zip)
joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
joe.to_a[1]   #=&gt; &quot;123 Maple, Anytown NC&quot;</pre>
            

            
            <div class="method-source-code" id="to_a-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_to_a(VALUE s)
{
    return rb_ary_new4(RSTRUCT_LEN(s), RSTRUCT_PTR(s));
}</code>
</pre> 
            </div><!-- to_a-source -->
            
          </div>

          

          
        </div><!-- to_a-method -->

      
        <div id="to_s-method" class="method-detail method-alias">
          <a name="method-i-to_s"></a>

          
          <div class="method-heading">
            <span class="method-name">to_s</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Struct.html#method-i-inspect">inspect</a>
          </div>
          
        </div><!-- to_s-method -->

      
        <div id="values-method" class="method-detail ">
          <a name="method-i-values"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a     &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">values   &rarr; array</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the values for this instance as an array.</p>

<pre>Customer = Struct.new(:name, :address, :zip)
joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
joe.to_a[1]   #=&gt; &quot;123 Maple, Anytown NC&quot;</pre>
            

            
            <div class="method-source-code" id="values-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_to_a(VALUE s)
{
    return rb_ary_new4(RSTRUCT_LEN(s), RSTRUCT_PTR(s));
}</code>
</pre> 
            </div><!-- values-source -->
            
          </div>

          

          
        </div><!-- values-method -->

      
        <div id="values_at-method" class="method-detail ">
          <a name="method-i-values_at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">values_at(selector,... )  &rarr; an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array containing the elements in <tt>self</tt> corresponding to
the given selector(s). The selectors may be either integer indices or
ranges. See also &lt;/code&gt;.select&lt;code&gt;.</p>

<pre>a = %w{ a b c d e f }
a.values_at(1, 3, 5)
a.values_at(1, 3, 5, 7)
a.values_at(-1, -3, -5, -7)
a.values_at(1..3, 2...5)</pre>
            

            
            <div class="method-source-code" id="values_at-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_struct_values_at(int argc, VALUE *argv, VALUE s)
{
    return rb_get_values_at(s, RSTRUCT_LEN(s), argc, argv, struct_entry);
}</code>
</pre> 
            </div><!-- values_at-source -->
            
          </div>

          

          
        </div><!-- values_at-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  

  </div><!-- documentation -->
<div id="disqus_thread" style='display:none'></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    // var disqus_shortname = 'rubydocbeta'; // required 
    var disqus_shortname = 'ruby-doc'; // required 
    
    var disqus_developer = true; // DEBUGGERY
    


    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink" style='display:none'>blog comments powered by <span class="logo-disqus">Disqus</span></a>

<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 1.9.2</small></p> 
  
   <p> <a href="http://www.ruby-doc.org">Ruby-doc.org</a> is managed by <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>. <a href="http://www.neurogami.com">Live curious.</a> </p>
 
    <p><small>Generated with the <a href="http://neurogami.com/code/">Rubydoc Rdoc Generator</a> 0.9.4</small>.</p>
  </div>

</div>

<script type="text/javascript">
var _uacct = "UA-335317-2";
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{ 
var pageTracker = _gat._getTracker(_uacct);
pageTracker._trackPageview();
} catch(err) {} 
</script>
</body>
</html>

