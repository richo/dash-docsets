<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Supported Protocols and Wrappers</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="context.params.html">Context parameters</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="wrappers.file.html">file://</a></div>
 <div class="up"><a href="langref.html">Language Reference</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="wrappers" class="reference">
 <h1 class="title">Supported Protocols and Wrappers</h1>
 <div class="partintro">
  <p class="para">
   PHP comes with many built-in wrappers for various URL-style protocols
   for use with the filesystem functions such as <span class="function"><a href="function.fopen.html" class="function">fopen()</a></span>,
   <span class="function"><a href="function.copy.html" class="function">copy()</a></span>, <span class="function"><a href="function.file-exists.html" class="function">file_exists()</a></span> and
   <span class="function"><a href="function.filesize.html" class="function">filesize()</a></span>.
   In addition to these wrappers, it is possible to register custom wrappers
   using the <span class="function"><a href="function.stream-wrapper-register.html" class="function">stream_wrapper_register()</a></span> function.
  </p>
  <blockquote class="note"><p><b class="note">Note</b>: 
   <span class="simpara">
    The URL syntax used to describe a wrapper only supports the
    <i>scheme://...</i> syntax. The <i>scheme:/</i>
    and <i>scheme:</i> syntaxes are not supported.
   </span>
  </p></blockquote>
 </div>
 
 







 







 







 







 







 







 







 







 







 







 







 







 
<h2>Table of Contents</h2><ul class="chunklist chunklist_reference"><li><a href="wrappers.file.html">file://</a> â€” Accessing local filesystem</li><li><a href="wrappers.http.html">http://</a> â€” Accessing HTTP(s) URLs</li><li><a href="wrappers.ftp.html">ftp://</a> â€” Accessing FTP(s) URLs</li><li><a href="wrappers.php.html">php://</a> â€” Accessing various I/O streams</li><li><a href="wrappers.compression.html">zlib://</a> â€” Compression Streams</li><li><a href="wrappers.data.html">data://</a> â€” Data (RFC 2397)</li><li><a href="wrappers.glob.html">glob://</a> â€” Find pathnames matching pattern</li><li><a href="wrappers.phar.html">phar://</a> â€” PHP Archive</li><li><a href="wrappers.ssh2.html">ssh2://</a> â€” Secure Shell 2</li><li><a href="wrappers.rar.html">rar://</a> â€” RAR</li><li><a href="wrappers.audio.html">ogg://</a> â€” Audio streams</li><li><a href="wrappers.expect.html">expect://</a> â€” Process Interaction Streams</li></ul>
</div>
<div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="105029""></a>
  <div class="note">
   <strong class="user">leonid at shagabutdinov dot com</strong>
   <a href="#105029" class="date">22-Jul-2011 09:45</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For https for windows enable this extension:<br />
<br />
extension=php_openssl.dll</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="104122""></a>
  <div class="note">
   <strong class="user">kwedeth at gmail dot com</strong>
   <a href="#104122" class="date">24-May-2011 06:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When daisy-chaining wrappers, I've found that the stream context only applies to the outside wrapper. For example, the following code will not work:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$options </span><span class="keyword">= array(</span><span class="string">'http'</span><span class="keyword">=&gt;array(</span><span class="string">'header'</span><span class="keyword">=&gt;</span><span class="string">"Accept-Encoding: gzip\r\n"</span><span class="keyword">));<br />
</span><span class="default">$context </span><span class="keyword">= </span><span class="default">stream_context_create</span><span class="keyword">(</span><span class="default">$options</span><span class="keyword">);<br />
<br />
</span><span class="default">$html </span><span class="keyword">= </span><span class="default">file_get_contents</span><span class="keyword">(</span><span class="string">'compress.zlib://<a href="http://example.com/resource.gz" rel="nofollow" target="_blank">http://example.com/resource.gz</a>'</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$context</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
The context in this case is useless for the compress.zlib:// wrapper but it does not get applied to <a href="http:// and the header will not be sent." rel="nofollow" target="_blank">http:// and the header will not be sent.</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102269""></a>
  <div class="note">
   <strong class="user">sebastian dot krebs at kingcrunch dot de</strong>
   <a href="#102269" class="date">04-Feb-2011 04:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The stream php://temp/maxmemory:$limit stores the data in memory unless the limit is reached. Then it will write the whole content the a temporary file and frees the memory. I didnt found a way to get at least some of the data back to memory.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83220""></a>
  <div class="note">
   <strong class="user">gjaman at gmail dot com</strong>
   <a href="#83220" class="date">15-May-2008 02:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can decompress (gzip) a input stream by combining wrappers:<br />
<br />
eg:&nbsp; $x = file_get_contents("compress.zlib://php://input"); <br />
<br />
I used this method to decompress a gzip stream that was pushed to my webserver</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="77169""></a>
  <div class="note">
   <strong class="user">jerry at gii dot co dot jp</strong>
   <a href="#77169" class="date">17-Aug-2007 10:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Not only are STDIN, STDOUT, and STDERR only allowed for CLI programs, but they are not allowed for programs that are read from STDIN. That can confuse you if you try to type in a simple test program.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75751""></a>
  <div class="note">
   <strong class="user">sander at medicore dot nl</strong>
   <a href="#75751" class="date">14-Jun-2007 04:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
to create a raw tcp listener system i use the following:<br />
<br />
xinetd daemon with config like:<br />
service test<br />
{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; disable&nbsp; &nbsp; &nbsp; = no<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; type&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = UNLISTED<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; socket_type&nbsp; = stream<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; protocol&nbsp; &nbsp;&nbsp; = tcp<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; bind&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = 127.0.0.1<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; port&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = 12345<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; wait&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = no<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; user&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = apache<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; group&nbsp; &nbsp; &nbsp; &nbsp; = apache<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; instances&nbsp; &nbsp; = 10<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; server&nbsp; &nbsp; &nbsp;&nbsp; = /usr/local/bin/php<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; server_args&nbsp; = -n [your php file here]<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; only_from&nbsp; &nbsp; = 127.0.0.1 #gotta love the security#<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; log_type&nbsp; &nbsp;&nbsp; = FILE /var/log/phperrors.log<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; log_on_success += DURATION<br />
}<br />
<br />
now use fgets(STDIN) to read the input. Creates connections pretty quick, works like a charm.Writing can be done using the STDOUT, or just echo. Be aware that you're completely bypassing the webserver and thus certain variables will not be available.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="70739""></a>
  <div class="note">
   <strong class="user">ben dot johansen at gmail dot com</strong>
   <a href="#70739" class="date">25-Oct-2006 02:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
followup:<br />
<br />
I found that if I added this line to the AJAX call, the values would show up in the $_POST<br />
<br />
xhttp.setRequestHeader('Content-Type',<br />
'application/x-www-form-urlencoded');</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69277""></a>
  <div class="note">
   <strong class="user">ben dot johansen at gmail dot com</strong>
   <a href="#69277" class="date">29-Aug-2006 11:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Example of how to use the php://input to get raw post data<br />
<br />
//read the raw data in<br />
$roughHTTPPOST = file_get_contents("php://input"); <br />
//parse it into vars<br />
parse_str($roughHTTPPOST);<br />
<br />
if you do readfile("php://input") you will get the length of the post data</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69255""></a>
  <div class="note">
   <strong class="user">ben dot johansen at gmail dot com</strong>
   <a href="#69255" class="date">29-Aug-2006 12:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In trying to do AJAX with PHP and Javascript, I came upon an issue where the POST argument from the following javascript could not be read in via PHP 5 using the $_REQUEST or $_POST. I finally figured out how to read in the raw data using the php://input directive.<br />
&nbsp;&nbsp;&nbsp; <br />
Javascript code:<br />
=============<br />
&nbsp;&nbsp; &nbsp;&nbsp; //create request instance&nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp;&nbsp; xhttp = new XMLHttpRequest();<br />
&nbsp;&nbsp; &nbsp;&nbsp; // set the event handler<br />
&nbsp;&nbsp; &nbsp;&nbsp; xhttp.onreadystatechange = serviceReturn;<br />
&nbsp;&nbsp; &nbsp;&nbsp; // prep the call, http method=POST, true=asynchronous call<br />
&nbsp;&nbsp; &nbsp;&nbsp; var Args = 'number='+NbrValue;<br />
&nbsp;&nbsp; &nbsp;&nbsp; xhttp.open("POST", "<a href="http://" rel="nofollow" target="_blank">http://</a><span class="default">&lt;?php </span><span class="keyword">echo </span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'SERVER_NAME'</span><span class="keyword">] </span><span class="default">?&gt;</span>/webservices/ws_service.php", true);<br />
&nbsp;&nbsp; &nbsp;&nbsp; // send the call with args<br />
&nbsp;&nbsp; &nbsp;&nbsp; xhttp.send(Args);<br />
<br />
PHP Code:<br />
&nbsp;&nbsp;&nbsp; //read the raw data in<br />
&nbsp;&nbsp;&nbsp; $roughHTTPPOST = file_get_contents("php://input"); <br />
&nbsp;&nbsp;&nbsp; //parse it into vars<br />
&nbsp;&nbsp;&nbsp; parse_str($roughHTTPPOST);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="67950""></a>
  <div class="note">
   <strong class="user">heitorsiller at uol dot com dot br</strong>
   <a href="#67950" class="date">07-Jul-2006 07:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For reading a XML stream, this will work just fine:<br />
<span class="default">&lt;?php<br />
<br />
$arq </span><span class="keyword">= </span><span class="default">file_get_contents</span><span class="keyword">(</span><span class="string">'php://input'</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Then you can parse the XML like this:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$xml </span><span class="keyword">= </span><span class="default">xml_parser_create</span><span class="keyword">();<br />
<br />
</span><span class="default">xml_parse_into_struct</span><span class="keyword">(</span><span class="default">$xml</span><span class="keyword">, </span><span class="default">$arq</span><span class="keyword">, </span><span class="default">$vs</span><span class="keyword">);<br />
<br />
</span><span class="default">xml_parser_free</span><span class="keyword">(</span><span class="default">$xml</span><span class="keyword">);<br />
<br />
</span><span class="default">$data </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">;<br />
<br />
foreach(</span><span class="default">$vs </span><span class="keyword">as </span><span class="default">$v</span><span class="keyword">){<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$v</span><span class="keyword">[</span><span class="string">'level'</span><span class="keyword">] == </span><span class="default">3 </span><span class="keyword">&amp;&amp; </span><span class="default">$v</span><span class="keyword">[</span><span class="string">'type'</span><span class="keyword">] == </span><span class="string">'complete'</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$data </span><span class="keyword">.= </span><span class="string">"\n"</span><span class="keyword">.</span><span class="default">$v</span><span class="keyword">[</span><span class="string">'tag'</span><span class="keyword">].</span><span class="string">" -&gt; "</span><span class="keyword">.</span><span class="default">$v</span><span class="keyword">[</span><span class="string">'value'</span><span class="keyword">];<br />
}<br />
<br />
echo </span><span class="default">$data</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
PS.: This is particularly useful for receiving mobile originated (MO) SMS messages from cellular phone companies.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="64343""></a>
  <div class="note">
   <strong class="user">opedroso at NOSPAMswoptimizer dot com</strong>
   <a href="#64343" class="date">12-Apr-2006 11:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
php://input allows you to read raw POST data. It is a less memory intensive alternative to $HTTP_RAW_POST_DATA and does not need any special php.ini directives. <br />
<br />
Example use:<br />
<br />
$httprawpostdata = file_get_contents("php://input");<br />
<br />
When reading a base64 encoded stream using php://input, be aware that you do not need to decode it, it will automatically be done for you.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="59151""></a>
  <div class="note">
   <strong class="user">nyvsld at gmail dot com</strong>
   <a href="#59151" class="date">27-Nov-2005 10:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
php://stdin supports fseek() and fstat() function call, <br />
while php://input doesn't.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="57142""></a>
  <div class="note">
   <strong class="user">drewish at katherinehouse dot com</strong>
   <a href="#57142" class="date">24-Sep-2005 11:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be aware that contrary to the way this makes it sound, under Apache, php://output and php://stdout don't point to the same place.<br />
<br />
<span class="default">&lt;?php<br />
$fo </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="string">'php://output'</span><span class="keyword">, </span><span class="string">'w'</span><span class="keyword">);<br />
</span><span class="default">$fs </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="string">'php://stdout'</span><span class="keyword">, </span><span class="string">'w'</span><span class="keyword">);<br />
<br />
</span><span class="default">fputs</span><span class="keyword">(</span><span class="default">$fo</span><span class="keyword">, </span><span class="string">"You can see this with the CLI and Apache.\n"</span><span class="keyword">);<br />
</span><span class="default">fputs</span><span class="keyword">(</span><span class="default">$fs</span><span class="keyword">, </span><span class="string">"This only shows up on the CLI...\n"</span><span class="keyword">);<br />
<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$fo</span><span class="keyword">);<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$fs</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Using the CLI you'll see:<br />
&nbsp; You can see this with the CLI and Apache.<br />
&nbsp; This only shows up on the CLI...<br />
<br />
Using the Apache SAPI you'll see:<br />
&nbsp; You can see this with the CLI and Apache.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52272""></a>
  <div class="note">
   <strong class="user">chris at free-source dot com</strong>
   <a href="#52272" class="date">26-Apr-2005 12:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you're looking for a unix based smb wrapper there isn't one built in,&nbsp; but I've had luck with <a href="http://www.zevils.com/cgi-bin/viewcvs.cgi/libsmbclient-php/ (tarball link at the end" rel="nofollow" target="_blank">http://www.zevils.com/cgi-bin/viewcvs.cgi/libsmbclient-php/ (tarball link at the end</a>).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45947""></a>
  <div class="note">
   <strong class="user">nargy at yahoo dot com</strong>
   <a href="#45947" class="date">24-Sep-2004 03:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When opening php://output in append mode you get an error, the way to do it:<br />
$fp=fopen("php://output","w");<br />
fwrite($fp,"Hello, world !&lt;BR&gt;\n");<br />
fclose($fp);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42722""></a>
  <div class="note">
   <strong class="user">aidan at php dot net</strong>
   <a href="#42722" class="date">27-May-2004 03:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The contants:<br />
<br />
* STDIN<br />
* STDOUT<br />
* STDERR<br />
<br />
Were introduced in PHP 4.3.0 and are synomous with the fopen('php://stdx') result resource.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="37842""></a>
  <div class="note">
   <strong class="user">lupti at yahoo dot com</strong>
   <a href="#37842" class="date">29-Nov-2003 02:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I find using file_get_contents with php://input is very handy and efficient. Here is the code:<br />
<br />
$request = "";<br />
$request = file_get_contents("php://input");<br />
<br />
I don't need to declare the URL filr string as "r". It automatically handles open the file with read.<br />
<br />
I can then use this $request string to your XMLparser as data.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="35009""></a>
  <div class="note">
   <strong class="user">sam at bigwig dot net</strong>
   <a href="#35009" class="date">15-Aug-2003 08:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
[ Editor's Note: There is a way to know.&nbsp; All response headers (from both the final responding server and intermediate redirecters) can be found in $http_response_header or stream_get_meta_data() as described above. ]<br />
<br />
If you open an HTTP url and the server issues a Location style redirect, the redirected contents will be read but you can't find out that this has happened.<br />
<br />
So if you then parse the returned html and try and rationalise relative URLs you could get it wrong.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="context.params.html">Context parameters</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="wrappers.file.html">file://</a></div>
 <div class="up"><a href="langref.html">Language Reference</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
